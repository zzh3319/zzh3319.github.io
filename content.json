[{"title":"Angular路由的定义和使用","date":"2015-07-17T16:00:00.000Z","path":"2015/07/18/angular/","text":"一、什么是routing（路由）Almost all non-trivial, non-demo Single Page App (SPA) require multiple pages. A settings page is different from a dashboard view. The login page is different from an accounts page（设置页面不同于控制页面，登录页面不同于账号信息页面。。。。就是说一个应用很多功能不同的页面） 我们可以使用Angular简单优雅地实现这个功能（页面之间的控制跳转…） 二、安装使用angular的路由功能需要安装routing模块…（引入angular-route.js就可以了） 三、定义定义路由非常容易，在我们的应用mian模块里面注入ngRoute依赖就可以了 angular.module(‘myApp’, [‘ngRoute’]) .config(function($routeProvider) {}); 现在，我们就可以给应用定义路由了。在路由模块里面的.config()方法里面注入了$routeProvider，上面的代码给我们演示了两个用于定义路由的方法。 when() when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。一般main route经常使用“/”来表示，也可以定义URL参数，在controller里面就使用$routeParams获取url参数。 templateUrl: 表示路由跳转的view模板controller: 控制器 angular.module(‘myApp’, [‘ngRoute’]) .config(function($routeProvider) { $routeProvider .when(‘/‘, { templateUrl: ‘views/main.html’, controller: ‘MainCtrl’ }) .when(‘/day/:id’, { templateUrl: ‘views/day.html’, controller: ‘DayCtrl’ })otherwise() otherwise()定义了当应用找不到指定路由的时候跳转的路由 angular.module(‘myApp’, [‘ngRoute’]).config(function($routeProvider) { $routeProvider .when(‘/‘, { templateUrl: ‘views/main.html’, controller: ‘MainCtrl’ }) .when(‘/day/:id’, { templateUrl: ‘views/day.html’, controller: ‘DayCtrl’ }) .otherwise({ redirectTo: ‘/‘ });}) 四、使用定义好了路由需要怎么使用呢?我们要告诉angular页面的哪一个部分是我们希望转换的，这需要使用到ng-view指令 &lt;div class=”header”&amp;gtMy page&lt;/div&gt;&lt;div ng-view&gt;&lt;/div&gt;&lt;span class=”footer”&gt;A footer&lt;/span&gt;” 这样就只有&lt;div ng-view&gt;&lt;/div&gt;会被更新， header/footer都始终保持不变","tags":[]},{"title":"Vue.js为什么不支持templateUrl模式","date":"2015-07-17T16:00:00.000Z","path":"2015/07/18/vue/","text":"这篇文章是翻译的Vue.js的官方blog，最后加了些自己的理解。 原文地址：Why Vue.js doesn’t support templateURL 很多Vue的新手，特别是使用过Angular的都会问“我能不能用 templateURL”,由于回答了太多次了，所以作者决定记下来。 Angular的世界里，templateURL 或者 ng-include 允许使用者在运行时动态的加载远程模板文件，这个看起来很方便，作为一个自带功能，但是让我们来重新审视下这个功能。 首先，它允许我们能够编写一个分离的html文件作为模板，这样子我们就能在编辑的时候看到正确的语法高亮，这也是很多开发者喜欢的原因（注：我觉得这是因为现在的人越来越懒，越来越依赖IDE的原因）。但是分离你的js和html代码真的是个好主意么？在Vue.js的组件中，js和html天然紧耦合，事实上，这些代码在一个文件更简单易懂。在2个文件中来回切换上下文逻辑实际上让开发者更不爽。在vue的概念里，组件才是vue.js的基本构建单位，并不是模板文件。每一个vue.js的模板都伴随着他的好基友js，分离他们太过于残忍了。 其次，因为templateURL是在运行时通过ajax的方式加载模板，不需要构建步骤为了你分离的文件。开发的时候，这很爽，但是上线部署的时候，你就麻烦了。在HTTP2.0没有大面积支持前，HTTP的请求数仍然是页面加载的最关键因素。想象一下，在你的网站中，每个组件都是用templateURL，那么页面出来前，你可能需要加载几十个HTTP请求。可能你并不知道，大多数的浏览器是限制同一域名的并发请求数量的。当你超过这个限额的时候，你页面的初始渲染时间就得等待每次请求的返回。当然，有工具可以帮助你提前注册你所有的模板，但是这就多了一个构建步骤，事实上，这就是大型网站的必然趋势。 那么，在没有templateURL的情况下，我们怎么处理开发环境问题呢？ 在js里面拼接字符串是很烂的做法，使用 &lt;script type=&quot;x/template&quot;&gt;这种伪模板也不咋样。那么，现在是时候提升技能，使用像Webpack或者Browserify这种流行的模块构建器了。如果以前没有使用过，可能有点望而却步，但是相信我，这会有一个质的飞跃。对于大型网站和系统来说，适当的模块化很必要。更重要的是，你可以编写Vue组件在一个文件中，再加上语法高亮，自定义的预处理器，热加载，ES6，内置css，自动前置。可以让开发者提高10倍效率。 最后，Vue还能懒加载你的组件，加上使用wabpack非常容易，尽管这是为了解决一个问—构建页面文件过于庞大，初始化比较慢，所以你最好还是分割开来比较好。 抛弃template，拥抱组件世界吧！！ 以上是原文的翻译，并非完全直译，有很多自己的语言，大概意思相同，原谅我的文采不行。 个人觉得，Vue的组件思想跟React相似，把很多东西放在了js（这里是.vue文件）中，这种做法是把很多紧耦合的东西集中在一起管理，把原来分割开的css,html，js合成在一起，这个很像很多年的做法，所以很同意玉伯说的，看起来前端是在原地打转了一圈，开发模式回到了从前的样子，但是已经螺旋上升了哦，一切都在升级。 通过最近的使用来看，这种component的方式很方便，天然帮你做了解耦的分离，当然你需要转化自己的思维模式，不能在用jquery的操作DOM方式，同时和Angular也有很多区别，Vue并非一个框架，而是更像一个类库，这样很灵活，当然也会有人使用非常hack的方式来编写代码，可能会很蛋疼，这就需要自己注意了，对于团队而言，可以很好的积累各种组件，同时功能切分，合作起来更加容易，就看团队对Vue的理解程度了。","tags":[]},{"title":"JavaScript 模块化入门Ⅰ：理解模块","date":"2015-07-17T16:00:00.000Z","path":"2015/07/18/model3/","text":"原文链接：JavaScript Modules: A Beginner’s Guide 作者：Preethi Kasireddy 作为一名JS初学者。假如你听到了一些诸如“模块化构建&amp;模块化载入” “Webpack&amp;Browserify” 或者 “AMD&amp;CMD”之类的术语，肯定瞬间就凌乱了。 JavaScript的模块化听起来挺深奥，可其实理解它对开发者来说特别实用。 在这篇文章里，我会尽量深入浅出地把这些深奥的术语翻译成浅显易懂的人话（加上一些代码示例）。希望你多少能从中学到点东西。为了避免长篇大论，整个内容会分为两篇文章，这是第一部分，主要介绍模块化是什么，为什么要使用模块。之后的第二部分会介绍如何打包JS模块，以及各类构建工具。 求解释到底什么是模块化称职的作家会把他的书分章节和段落；好的程序员会把他的代码分成模块。 就好像书籍的一章，模块仅仅是一坨代码而已。 好的代码模块分割的内容一定是很合理的，便于你增加减少或者修改功能，同时又不会影响整个系统。 为什么要使用模块模块化可以使你的代码低耦合，功能模块直接不相互影响。我个人认为模块化主要有以下几点好处： 1.可维护性：根据定义，每个模块都是独立的。良好设计的模块会尽量与外部的代码撇清关系，以便于独立对其进行改进和维护。维护一个独立的模块比起一团凌乱的代码来说要轻松很多。 2.命名空间：在JavaScript中，最高级别的函数外定义的变量都是全局变量（这意味着所有人都可以访问到它们）。也正因如此，当一些无关的代码碰巧使用到同名变量的时候，我们就会遇到“命名空间污染”的问题。 这样的问题在我们开发过程中是要极力避免的。 后面的内容里我也会举一些具体的例子来说明这一点。 3.可复用性：现实来讲，在日常工作中我们经常会复制自己之前写过的代码到新项目中。 复制粘贴虽然很快很方便，但难道我们找不到更好的办法了么？要是……有一个可以重复利用的模块岂不妙哉？ 如何引入模块引入模块有很多种方式，这里我们先介绍一些： 模块模式 模块模式一般用来模拟类的概念（因为原生JavaScript并不支持类，虽然最新的ES6里引入了Class不过还不普及）这样我们就能把公有和私有方法还有变量存储在一个对象中——这就和我们在Java或Python里使用类的感觉一样。这样我们就能在公开调用API的同时，仍然在一个闭包范围内封装私有变量和方法。 实现模块模式的方法有很多种，下面的例子是通过匿名闭包函数的方法。（在JavaScript中，函数是创建作用域的唯一方式。） 例1：匿名闭包函数// 在函数的作用域中下面的变量是私有的123456789101112131415161718192021(function () &#123; var myGrades = [93, 95, 88, 0, 55, 91]; var average = function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item&#125;, 0); return &apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125; var failing = function()&#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70;&#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125; console.log(failing());&#125;()); // 控制台显示：’You failed 2 times.’通过这种构造，我们的匿名函数有了自己的作用域或“闭包”。 这允许我们从父（全局）命名空间隐藏变量。 这种方法的好处在于，你可以在函数内部使用局部变量，而不会意外覆盖同名全局变量，但仍然能够访问到全局变量，如下所示： 123456789101112131415161718192021222324var global = &apos;Hello, I am a global variable :)&apos;;(function () &#123; // 在函数的作用域中下面的变量是私有的 var myGrades = [93, 95, 88, 0, 55, 91]; var average = function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item&#125;, 0); return &apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125; var failing = function()&#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70;&#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125; console.log(failing()); console.log(global);&#125;()); // 控制台显示：’You failed 2 times.’// 控制台显示：’Hello, I am a global variable :)’要注意的是，一定要用括号把匿名函数包起来，以关键词function开头的语句总是会被解释成函数声明（JS中不允许没有命名的函数声明），而加上括号后，内部的代码就会被识别为函数表达式。其实这个也叫作立即执行函数（IIFE）感兴趣的同学可以在这里了解更多 例2：全局引入另一种比较受欢迎的方法是一些诸如jQuery的库使用的全局引入。和我们刚才举例的匿名闭包函数很相似，只是传入全局变量的方法不同： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657(function (globalVariable) &#123; // 在函数的作用域中下面的变量是私有的 var privateFunction = function() &#123; console.log(&apos;Shhhh, this is private!&apos;); &#125; // 通过全局变量设置下列方法的外部访问接口 // 与此同时这些方法又都在函数内部 globalVariable.each = function(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;; globalVariable.filter = function(collection, test) &#123; var filtered = []; globalVariable.each(collection, function(item) &#123; if (test(item)) &#123; filtered.push(item); &#125; &#125;); return filtered; &#125;; globalVariable.map = function(collection, iterator) &#123; var mapped = []; globalUtils.each(collection, function(value, key, collection) &#123; mapped.push(iterator(value)); &#125;); return mapped; &#125;; globalVariable.reduce = function(collection, iterator, accumulator) &#123; var startingValueMissing = accumulator === undefined; globalVariable.each(collection, function(item) &#123; if(startingValueMissing) &#123; accumulator = item; startingValueMissing = false; &#125; else &#123; accumulator = iterator(accumulator, item); &#125; &#125;); return accumulator; &#125;; &#125;(globalVariable)); 在这个例子中，globalVariable 是唯一的全局变量。这种方法的好处是可以预先声明好全局变量，让你的代码更加清晰可读。 例3：对象接口像下面这样，还有一种创建模块的方法是使用独立的对象接口： 123456789101112131415161718192021222324252627282930var myGradesCalculate = (function () &#123; // 在函数的作用域中下面的变量是私有的 var myGrades = [93, 95, 88, 0, 55, 91]; // 通过接口在外部访问下列方法 // 与此同时这些方法又都在函数内部 return &#123; average: function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item; &#125;, 0); return&apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125;, failing: function() &#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70; &#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125; &#125;&#125;)();myGradesCalculate.failing(); // &apos;You failed 2 times.&apos; myGradesCalculate.average(); // &apos;Your average grade is 70.33333333333333.&apos; 例4：揭示模块模式 Revealing module pattern这和我们之前的实现方法非常相近，除了它会确保，在所有的变量和方法暴露之前都会保持私有： 12345678910111213141516171819202122232425262728293031var myGradesCalculate = (function () &#123; // 在函数的作用域中下面的变量是私有的 var myGrades = [93, 95, 88, 0, 55, 91]; var average = function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item; &#125;, 0); return&apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125;; var failing = function() &#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70; &#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125;; // 将公有指针指向私有方法 return &#123; average: average, failing: failing &#125;&#125;)();myGradesCalculate.failing(); // &apos;You failed 2 times.&apos; myGradesCalculate.average(); // &apos;Your average grade is 70.33333333333333.&apos; 到这里，其实我们只聊了模块模式的冰山一角。感兴趣的朋友可以阅读更详细的资料： 深入理解JavaScript 模块模式深入理解JavaScript系列（3）：全面解析Module模式 CommonJS &amp; AMD上述的所有解决方案都有一个共同点：使用单个全局变量来把所有的代码包含在一个函数内，由此来创建私有的命名空间和闭包作用域。 虽然每种方法都比较有效，但也都有各自的短板。 有一点，作为开发者，你必须清楚地了解引入依赖文件的正确顺序。就拿Backbone.js来举个例子，想要使用Backbone就必须在你的页面里引入Backbone的源文件。 然而Backbone又依赖 Underscore.js，所以Backbone的引入必须在其之后。 而在工作中，这些依赖管理经常会成为让人头疼的问题。 另外一点，这些方法也有可能引起命名空间冲突。举个例子，要是你碰巧写了俩重名的模块怎么办？或者你同时需要一个模块的两个版本时该怎么办？ 难道就没有不通过全局作用域来实现的模块方法么？ 当然是有的。 接下来介绍两种广受欢迎的解决方案：CommonJS 和 AMD. CommonJSCommonJS 扩展了JavaScript声明模块的API. CommonJS模块可以很方便得将某个对象导出，让他们能够被其他模块通过 require 语句来引入。要是你写过 Node.js 应该很熟悉这些语法。 通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入。 还是举个直观的例子吧： 1234567891011function myModule() &#123; this.hello = function() &#123; return &apos;hello!&apos;; &#125; this.goodbye = function() &#123; return &apos;goodbye!&apos;; &#125;&#125;module.exports = myModule; 通过指定导出的对象名称，CommonJS模块系统可以识别在其他文件引入这个模块时应该如何解释。 然后在某个人想要调用 myMoudle 的时候，只需要 require 一下： 12345var myModule = require(&apos;myModule&apos;);var myModuleInstance = new myModule();myModuleInstance.hello(); // &apos;hello!&apos;myModuleInstance.goodbye(); // &apos;goodbye!&apos; 这种实现比起模块模式有两点好处： 避免全局命名空间污染明确代码之间的依赖关系并且这种书写方式也非常舒服友好，我自己很喜欢。 需要注意的一点是，CommonJS以服务器优先的方式来同步载入模块，假使我们引入三个模块的话，他们会一个个地被载入。 它在服务器端用起来很爽，可是在浏览器里就不会那么高效了。毕竟读取网络的文件要比本地耗费更多时间。只要它还在读取模块，浏览器载入的页面就会一直卡着不动。（在下一篇第二部分的教程里我们会讨论如何解决这个问题） AMDCommonJS已经挺不错了，但假使我们想要实现异步加载模块该怎么办？答案就是Asynchronous Module Definition（异步模块定义规范），简称AMD. 通过AMD载入模块的代码一般这么写：123define([&apos;myModule&apos;, &apos;myOtherModule&apos;], function(myModule, myOtherModule) &#123; console.log(myModule.hello());&#125;); 这里我们使用 define 方法，第一个参数是依赖的模块，这些模块都会在后台无阻塞地加载，第二个参数则作为加载完毕的回调函数。 回调函数将会使用载入的模块作为参数。在这个例子里就是 myMoudle 和 myOtherModule.最后，这些模块本身也需要通过 define 关键词来定义。 拿 myModule 来举个例子： 1234567891011define([], function() &#123; return &#123; hello: function() &#123; console.log(&apos;hello&apos;); &#125;, goodbye: function() &#123; console.log(&apos;goodbye&apos;); &#125; &#125;;&#125;); 重申一下，不像CommonJS，AMD是优先浏览器的一种异步载入模块的解决方案。（记得，很多人认为一个个地载入小文件是很低效的，我们将在下一篇文章理介绍如何打包模块） 除了异步加载以外，AMD的另一个优点是你可以在模块里使用对象、函数、构造函数、字符串、JSON或者别的数据类型，而CommonJS只支持对象。 再补充一点，AMD不支持Node里的一些诸如 IO,文件系统等其他服务器端的功能。另外语法上写起来也比CommonJS麻烦一些。 UMD在一些同时需要AMD和CommonJS功能的项目中，你需要使用另一种规范：Universal Module Definition（通用模块定义规范）。 UMD创造了一种同时使用两种规范的方法，并且也支持全局变量定义。所以UMD的模块可以同时在客户端和服务端使用。 下面是一个解释其功能的例子：1234567891011121314151617181920212223(function (root, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; // AMD define([&apos;myModule&apos;, &apos;myOtherModule&apos;], factory); &#125; else if (typeof exports === &apos;object&apos;) &#123; // CommonJS module.exports = factory(require(&apos;myModule&apos;), require(&apos;myOtherModule&apos;)); &#125; else &#123; // Browser globals (Note: root is window) root.returnExports = factory(root.myModule, root.myOtherModule); &#125;&#125;(this, function (myModule, myOtherModule) &#123; // Methods function notHelloOrGoodbye()&#123;&#125;; // A private method function hello()&#123;&#125;; // A public method because it&apos;s returned (see below) function goodbye()&#123;&#125;; // A public method because it&apos;s returned (see below) // Exposed public methods return &#123; hello: hello, goodbye: goodbye &#125;&#125;)); 更多有关UMD的例子请看其Github上的官方repo. 原生JS希望你坚持读到了现在，我们最后再介绍一种定义模块的方式。 你可能注意到了，上述的这几种方法都不是JS原生支持的。要么是通过模块模式来模拟，要么是使用CommonJS或AMD. 幸运的是在JS的最新规范ECMAScript 6 (ES6)中，引入了模块功能。 ES6 的模块功能汲取了CommonJS 和 AMD 的优点，拥有简洁的语法并支持异步加载，并且还有其他诸多更好的支持。 我最喜欢的ES6 模块功能的特性是，导入是实时只读的。（CommonJS 只是相当于把导出的代码复制过来）。 来看例子：12345678910111213141516171819202122232425// lib/counter.jsvar counter = 1;function increment() &#123; counter++;&#125;function decrement() &#123; counter--;&#125;module.exports = &#123; counter: counter, increment: increment, decrement: decrement&#125;;// src/main.jsvar counter = require(&apos;../../lib/counter&apos;);counter.increment();console.log(counter.counter); // 1 上面这个例子中，我们一共创建了两份模块的实例，一个在导出的时候，一个在引入的时候。 在 main.js 当中的实例是和原本模块完全不相干的。这也就解释了为什么调用了 counter.increment() 之后仍然返回1。因为我们引入的 counter 变量和模块里的是两个不同的实例。 所以调用 counter.increment() 方法只会改变模块中的 counter .想要修改引入的 counter 只有手动一下啦：12345678910111213141516171819202122counter.counter++;console.log(counter.counter); // 2//而通过 import 语句，可以引入实时只读的模块：// lib/counter.jsexport let counter = 1;export function increment() &#123; counter++;&#125;export function decrement() &#123; counter--;&#125;// src/main.jsimport * as counter from &apos;../../counter&apos;;console.log(counter.counter); // 1counter.increment();console.log(counter.counter); // 2 这看起来很酷不是么？这样就实现了我们把模块分隔在不同的文件里，需要的时候又可以合并在一起而且不影响它的功能。 我想看到这里的你应该已经对JavaScript模块化有了进一步的了解。","tags":[]},{"title":"JavaScript 模块化入门Ⅱ：模块打包构建","date":"2015-07-17T16:00:00.000Z","path":"2015/07/18/model4/","text":"原文链接：JavaScript Modules Part 2: Module Bundling 作者：Preethi Kasireddy 在上一篇教程里我们已经讨论过什么是模块，为什么要使用模块以及多种实现模块化的方式。 这次，我们会聊一聊什么是模块打包，为什么要打包模块，模块打包的方式工具，还有它当前在Web开发中的运用。 什么是模块打包？粗俗一点来讲，模块打包就是把一小坨一小坨的代码粘成一大坨。 实际操作起来的时候当然还需要关注一些细节。 为什么要打包模块？一般来讲，我们用模块化组织代码的时候，都会把模块划分在不同的文件和文件夹里，也可能会包含一些诸如React和Underscore一类的第三方库。 而后，所有的这些模块都需要通过&lt;script&gt;标签引入到你的HTML文件中，然后用户在访问你网页的时候它才能正常显示和工作。每个独立的&lt;script&gt;标签都意味着，它们要被浏览器分别一个个地加载。 这就有可能导致页面载入时间过长。 为了解决这个问题，我们就需要进行模块打包，把所有的模块合并到一个或几个文件中，以此来减少HTTP请求数。这也可以被称作是从开发到上线前的构建环节。 还有一种提升加载速度的做法叫做代码压缩（混淆）。其实就是去除代码中不必要的空格、注释、换行符一类的字符，来保证在不影响代码正常工作的情况下压缩其体积。 更小的文件体积也就意味着更短的加载时间。要是你仔细对比过带有 .min后缀的例如 jquery.min.js和jquery.js的话，应该会发现压缩版的文件相较之下要小很多。 Gulp和Grunt一类的构建工具可以很方便地解决上述的需求，在开发的时候通过模块来组织代码，上线时再合并压缩提供给浏览器。 打包模块的方法有哪些？如果你的代码是通过之前介绍过的模块模式来组织的，合并和压缩它们其实就只是把一些原生的JS代码合在一起而已。 但如果你使用的是一些浏览器原生不支持的模块系统（例如CommonJS 或 AMD，以及ES6 模块的支持现在也不完整），你就需要使用一些专门的构建工具来把它们转换成浏览器支持的代码。这类工具就是我们最近经常听说的Browserify, RequireJS, Webpack等等模块化构建、模块化加载工具了。 为了实现模块化构建或载入的功能，这类工具提供许多诸如在你改动源代码后自动重新构建（文件监听）等一系列的功能。 下面我们就一起来看一些实际的例子吧： 打包 CommonJS在上一篇教程中我们了解到， CommonJS是同步载入模块的，这对浏览器来说不是很理想。其实下面介绍的模块化构建工具Browserify在上一篇也提到过。它是一个专门用来打包CommonJS模块以便在浏览器里运行的构建工具。 举个例子，假如你在 main.js 文件中引入了一个用来计算平均数的功能模块：12345var myDependency = require(&apos;myDependency&apos;);var myGrades = [93, 95, 88, 0, 91];var myAverageGrade = myDependency.average(myGrades); 在这个示例中，我们只有一个名为 myDependency 的模块依赖。通过下面的命令，Browserify会依次把main.js里引入的所有模块一同打包到一个名为 bundle.js 的文件里： browserify main.js -o bundle.jsBrowserify 首先会通过抽象语法树（AST）来解析代码中的每一个 require 语句，在分析完所有模块的依赖和结构之后，就会把所有的代码合并到一个文件中。然后你在HTML文件里引入一个bundle.js就够啦。 多个文件和多个依赖也只需要再稍微配置一下就能正常工作了。 之后你也可以使用一些例如MinifyJS的工具来压缩代码。 打包 AMD假若你使用的是AMD，你会需要一些例如RequireJS 或 Curl的AMD加载器。模块化加载工具可以在你的应用中按需加载模块代码。 需要再次提醒一下，AMD 和 CommonJS 的最主要区别是AMD是异步加载模块的。这也就意味着你不是必须把所有的代码打包到一个文件里，模块加载不影响后续语句执行，逐步加载的的模块也不会导致页面阻塞无法响应。 不过在实际应用中，为了避免用户过多的请求对服务器造成压力。大多数的开发者还是选择用RequireJS optimizer, r.js一类的构建工具来合并和压缩AMD的模块。 总的来说，AMD 和 CommonJS 在构建中最大的区别是，在开发过程中，采用AMD的应用直到正式上线发布之前都不需要构建。 要是你对CommonJS vs. AMD的讨论感兴趣，可以看这一篇AMD is Not the Answer WebpackWebpack 是新推出的构建工具里最受欢迎的。它兼容CommonJS, AMD, ES6各类规范。 也许你会质疑，我们已经有这么多诸如Browserify 或 RequireJS 的工具了，为什么还需要 Webpack 呢？究其原因之一，Webpack 提供许多例如 code splitting（代码分割） 的有用功能，它可以把你的代码分割成一个个的 chunk 然后按需加载优化性能。 举个例子，要是你的Web应用中的一些代码只在很少的情况下才会被用到，把它们全都打包到一个文件里是很低效的做法。所以我们就需要 code splitting 这样的功能来实现按需加载。而不是把那些很少人才会用到的代码一股脑儿全都下载到客户端去。 code splitting 只是 Webpack 提供的众多强大功能之一。当然，网上也为这些模块化构建工具吵得不可开交。你要是感兴趣的话也可以在下面这些地方观摩一下： https://gist.github.com/substack/68f8d502be42d5cd4942Browserify vs. WebpackBrowserify VS Webpack ES6 模块看他们吵够了的话，接下来我就要介绍一下ES6模块了。假如你采用ES6模块，在不远的将来对那些构建工具的需求可能会小一些。首先我们还是看看ES6模块是怎么加载的吧。 ES6模块和CommonJS, AMD一类规范最主要的区别是，当你载入一个模块时，载入的操作实际实在编译时执行的——也就是在代码执行之前。所以去掉那些不必要的exports导出语句可以优化我们应用的性能。 有一个经常会被问到的问题：去除exports和冗余代码消除（UglifyJS一类工具执行后的效果）之间有什么区别？ 答案是这个要具体情况具体分析，感兴趣的话可以上Github看这个Repo：Rollup’s wiki 让ES6模块与冗余代码消除（Dead code elimination）不同的是一种叫做tree shaking的技术。Tree shaking其实恰好是冗余代码消除的反向操作。它只加载你需要调用的代码，而不是删掉不会被执行的代码。我们还是用一个具体的例子说明吧： 假设我们有如下一个使用ES6语法，名为 utils.js 的函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344export function each(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;export function filter(collection, test) &#123; var filtered = []; each(collection, function(item) &#123; if (test(item)) &#123; filtered.push(item); &#125; &#125;); return filtered;&#125;export function map(collection, iterator) &#123; var mapped = []; each(collection, function(value, key, collection) &#123; mapped.push(iterator(value)); &#125;); return mapped;&#125;export function reduce(collection, iterator, accumulator) &#123; var startingValueMissing = accumulator === undefined; each(collection, function(item) &#123; if(startingValueMissing) &#123; accumulator = item; startingValueMissing = false; &#125; else &#123; accumulator = iterator(accumulator, item); &#125; &#125;); return accumulator;&#125; 现在我们也不清楚到底需要这个函数的哪些功能，所以先全部引入到 main.js 中： //main.jsimport * as Utils from ‘./utils.js’;之后我们再调用一下 each 函数： //main.jsimport * as Utils from ‘./utils.js’; Utils.each([1, 2, 3], function(x) { console.log(x) });通过 “tree shaken” 之后的 main.js 看起来就像下面这样：123456789101112131415//treeshake.js function each(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;;each([1, 2, 3], function(x) &#123; console.log(x) &#125;);注意到这里只导出了我们调用过的 each 方法。 再如果我们只调用 filter 方法的话：123456789101112131415161718192021222324252627282930//main.jsimport * as Utils from &apos;./utils.js&apos;;Utils.filter([1, 2, 3], function(x) &#123; return x === 2 &#125;);&quot;Tree shaken&quot; 之后就会变成这样：function each(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;;function filter(collection, test) &#123; var filtered = []; //注意在filter中调用了each，所以两个方法都会被引入 each(collection, function(item) &#123; if (test(item)) &#123; filtered.push(item); &#125; &#125;); return filtered;&#125;;filter([1, 2, 3], function(x) &#123; return x === 2 &#125;); 很神奇不是么？ 你也可以自己在Rollup.js的实时预览编辑器里做做试验：live demo and editor 构建ES6模块现在我们已经了解到ES6模块载入的与众不同了，但我们还没有聊到底该怎么构建ES6模块。 因为浏览器对ES6模块的原生支持还不够完善，所以现阶段还需要我们做一些补充工作。 让ES6模块在浏览器中顺利运行的常用方法有以下几种： 1.使用语法编译器（Babel或Traceur）来把ES6语法的代码编译成ES5或者CommonJS, AMD, UMD等其他形式。然后再通过Browserify 或 Webpack 一类的构建工具来进行构建。 2.使用Rollup.js，这其实和上面差不多，只是Rollup还会捎带的利用“tree shaking”技术来优化你的代码。在构建ES6模块时Rollup优于Browserify或Webpack的也正是这一点，它打包出来的文件体积会更小。Rollup也可以把你的代码转换成包括ES6, CommonJS, AMD, UMD, IIFE在内的各种格式。其中IIFE和UMD可以直接在浏览器里运行，AMD, CommonJS, ES6等还需要你通过Browserify, Webpack, RequireJS一类的工具才能在浏览器中使用。 小心踩坑这里有一些坑还需要和大家说明一下。转换语法优雅的ES6代码以便在浏览器里运行并不是一件令人舒爽的事情。 问题在于，什么时候我们才能免去这些多余的工作。 令人感动的答案是：“差不多快了。” ECMAScript目前包含一个名为ECMAScript 6 module loader API 的解决方案。简单来讲，这个解决方案允许你动态加载模块并缓存。还是来举例说明：12345678910111213141516171819202122### myModule.jsexport class myModule &#123; constructor() &#123; console.log(&apos;Hello, I am a module&apos;); &#125; hello() &#123; console.log(&apos;hello!&apos;); &#125; goodbye() &#123; console.log(&apos;goodbye!&apos;); &#125;&#125;### main.jsSystem.import(&apos;myModule&apos;).then(function(myModule) &#123; new myModule.hello();&#125;);// ‘Hello!, I am a module!’ 同样，你可以在script标签上设置type=module的属性来直接定义模块：12345&amp;lt;script type=&quot;module&quot;&amp;gt; // loads the &apos;myModule&apos; export from &apos;mymodule.js&apos; import &#123; hello &#125; from &apos;mymodule&apos;; new Hello(); // &apos;Hello, I am a module!&apos;&amp;lt;/script&amp;gt; 更加详细的介绍也可以在Github上查看：es6-module-loader 如果你现在就想测试这个解决方案的话，我在这里也安利一下 SystemJS. SystemJS支持在浏览器端和Node动态加载之前介绍过所有格式的模块（ES6 modules, AMD, CommonJS等），通过把已加载的模块还存在”module registry”里来避免重复加载。它也同样支持转换ES6的代码至其他格式。 我们已经有了原生ES6模块，还需要那些乱七八糟的玩意儿么？越来越多的人使用ES6模块产生了一些有趣的影响： HTTP/2 出现之后，模块化构建工具是不是都该被淘汰了？ 在HTTP/1中，一次TCP连接只允许一个请求，所以我们需要通过减少载入的文件数来优化性能。而HTTP/2改变了这一切，请求和响应可以并行，一次连接也允许多个请求。 每次请求的消耗也会远远小于HTTP/1，所以载入一堆模块就不再是一个影响性能的问题了。所以许多人认为打包模块完全就是多余的了。这听起来很合理，但我们也需要具体情况具体分析。 其中有一条，模块化构建解决了一些HTTP/2解决不了的问题。例如去除冗余的代码以压缩体积。要是你开发的是一个对性能要求很高的网站，模块化构建从长远上考虑会给你带来更多好处。当然，要是你不那么在意性能问题，以后完全就可以省却这些烦人的步骤了。 总之，我们离所有的网站都采用HTTP/2传输还有相当一段时间。短期内模块化构建还是很有必要的。 要是你对HTTP/2的其他特性也感兴趣，可以查阅这里：HTTP/2 CommonJS , AMD, UMD这类标准会过时么？ 一旦ES6成为了模块化的标准，我们还需要这些非原生的东西么？ 这点还值得商榷。 在JavaScript中采用统一标准，通过import和export来使用模块，省略所有繁杂的多余步骤确实很爽。不过到底要多久ES6才能成为真正的模块化标准呢？ 反正不会很快。 并且开发者也有各自的偏好，“唯一的解决方案”永远也不会存在。 总结我希望这两篇文章对于你理解JS模块有所帮助，要是你忘了之前聊过的内容，可以现在点开再看看：","tags":[]},{"title":"Welcome To My Blog","date":"2015-07-12T16:00:00.000Z","path":"2015/07/13/me/","text":"欢迎您的到来！","tags":[]},{"title":"前端面试知识点总结","date":"2015-07-12T16:00:00.000Z","path":"2015/07/13/mianshi1/","text":"一、html+css部分、（1）css盒模型，可能会要求手写一个布局，这个布局基本上用到的css是margin的负值，boxing-sizing：border-box，布局尽量往这方面想。浏览器布局的基本元素是盒，在w3c的标准模式下，width=width，但是在怪异模式下，width=border2+padding2+width;其中后代元素的width：100%；参照的是右边的那个width， （2）html5的新特性 1、标签语义化，比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签2、音视频元素，video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。 3、新增很多api，比如获取用户地理位置的window.navigator.geoloaction， 4、websocket websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端， 5、webstorage，webstorage是本地存储，存储在客户端，包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了， 6、缓存 html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下： 1、首先给html添加manifest属性，并赋值为cache.manifest2、cache.manifest的内容为: CACHE MANIFEST #v1.2 CACHE : //表示需要缓存的文件 a.js b.js NETWORK: //表示只在用户在线的时候才需要的文件，不会缓存 c.js FALLBACK / /index.html //表示如果找不到第一个资源就用第二个资源代替 7、web worker，web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。 （3）对html5的语义话的理解 html5的语义化指的是用正确的标签包含正确的内容，比如nav标签，里面就应该包含导航条的内容，而不是用做其他的用途，标签语义化的好处就是结构良好，便于阅读，方便威化，也有利于爬虫的查找，提高搜索率。 （4）cookie，sessionStorage，localeStorage的区别 cookie是存储在浏览器端，并且随浏览器的请求一起发送到服务器端的，它有一定的过期时间，到了过期时间自动会消失。sessionStorage和localeStorage也是存储在客户端的，同属于web Storage，比cookie的存储大小要大有8m，cookie只有4kb，localeStorage是持久化的存储在客户端，如果用户不手动清除的话，不会自动消失，会一直存在，sessionStorage也是存储在客户端，但是它的存活时间是在一个回话期间，只要浏览器的回话关闭了就会自动消失。 （5）多个页面之间如何进行通信 使用cookie，使用web worker，使用localeStorage和sessionStorage （6）浏览器的渲染过程 1、首先获取html，然后构建dom树 2、其次根据css构建render树，render树中不包含定位和几何信息 3、最后构建布局数，布局是含有元素的定位和几何信息 （7）重构、回流 浏览器的重构指的是改变每个元素外观时所触发的浏览器行为，比如颜色，背景等样式发生了改变而进行的重新构造新外观的过程。重构不会引发页面的重新布局，不一定伴随着回流， 回流指的是浏览器为了重新渲染页面的需要而进行的重新计算元素的几何大小和位置的，他的开销是非常大的，回流可以理解为渲染树需要重新进行计算，一般最好触发元素的重构，避免元素的回流；比如通过通过添加类来添加css样式，而不是直接在DOM上设置，当需要操作某一块元素时候，最好使其脱离文档流，这样就不会引起回流了，比如设置position：absolute或者fixed，或者display：none，等操作结束后在显示。 二、JavaScript部分（1）JavaScript的数据类型 基本数据类型：Number，String，Boolean，Undefined，Null 复杂数据类型：Object，Array，Function，RegExp，Date，Error 全局数据类型：Math （2）JavaScript的闭包 闭包简单的说就是一个函数能访问外部函数的变量，这就是闭包，比如说： function a(x){ var tem=3; function b(y){ console.log(x+y+(++tem)); }}a函数中的b函数就是闭包了，b函数可以使用a函数的局部变量，参数，最典型的闭包应该是下面这样，将定义在函数中的函数作为返回值 function a(x){ var tem=3; function b(y){ console.log(x+y+(++tem)); }return b;}闭包的缺点是，因为内部闭包函数可以访问外部函数的变量，所以外部函数的变量不能被释放，如果闭包嵌套过多，会导致内存占用大，要合理使用闭包。 （3）new 操作符到底做了什么 首先，new操作符为我们创建一个新的空对象，然后this变量指向该对象， 其次，空对象的原型执行函数的原型， 最后，改变构造函数内部的this的指向 代码如下： var obj={};obj.proto=fn.prototype;fn.call(obj);（4）改变函数内部this指针的指向函数 call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);那么问题来了，call和apply的区别是什么，其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。还有一个bind函数， var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内的this指针指向obj对象。 （5）JavaScript的作用域和作用域链 JavaScript的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到外部的作用域中去查找，还是没有的话，就到在外面一层作用域中找，直到到window所在的作用域，每个函数在声明的时候就默认有一个外部作用域链存在了，比如： var t=4;function foo(){ var tem=12; funciton bar(){ var temo=34; console.log(t+” “+tem+” “+temo); }}在bar函数中找t变量的过程就是，先到自己的内部作用域中找，发现没有找到，然后到bar所在的最近的外部环境中找，也就是foo的内部作用域，还是没有找到，再到window的作用域中找，结果找到了 （6）JavaScript的继承 function A(name){ this.name=name; }A.prototype.sayName=function(){ console.log(this.name); }function B(age){ this.age=age; }原型继承 B.prototype=new A(“mbj”); //被B的实例共享var foo=new B(18);foo.age; //18,age是本身携带的属性foo.name; //mbj，等价于foo.proto.namefoo.sayName(); //mbj,等价于foo.proto.proto.sayName()foo.toString(); //“[object Object]”,等价于foo.proto.proto.proto.toString();这样B通过原型继承了A，在new B的时候，foo中有个隐藏的属性proto指向构造函数的prototype对象，在这里是A对象实例，A对象里面也有一个隐藏的属性proto,指向A构造函数的prototype对象，这个对象里面又有一个proto__指向Object的prototype 这种方式的缺第一个缺点是所有子类共享父类实例，如果某一个子类修改了父类，其他的子类在继承的时候，会造成意想不到的后果。第二个缺点是在构造子类实例的时候，不能给父类传递参数。 构造函数继承 function B(age,name){ this.age=age;A.call(this,name); }var foo=new B(18,”wmy”);foo.name; //wmyfoo.age; //18foo.sayName(); //undefined采用这种方式继承是把A中的属性加到this上面，这样name相当于就是B的属性，sayName不在A的构造函数中，所以访问不到sayName。这种方法的缺点是父类的prototype中的函数不能复用。 原型继承+构造函数继承 function B(age,name){ this.age=age;A.call(this,name); }B.prototype=new A(“mbj”);var foo=new B(18,”wmy”);foo.name; //wmyfoo.age; //18foo.sayName(); //wmy这样就可以成功访问sayName函数了，结合了上述两种方式的优点，但是这种方式也有缺点，那就是占用的空间更大了。 （7）JavaScript变量提升 请看下面代码 var bar=1;function test(){ console.log(bar); //undeifned var bar=2; console.log(bar); //2}test();为什么在test函数中会出现上述结果呢，这就是JavaScript的变量提升了，虽然变量bar的定义在后面，不过浏览器在解析的时候，会把变量的定义放到最前面，上面的test函数相当于 function test(){ var bar; console.log(bar); //undefined bar=2; console.log(bar); //2}再看 var foo=function(){ console.log(1); }function foo(){ console.log(2); }foo(); //结果为1同样的，函数的定义也会到提升到最前面，上面的代码相当于function foo(){ console.log(2); }var foo;foo=funciton(){ console.log(1); }foo(); //1（8）JavaScript事件模型 原始事件模型，捕获型事件模型，冒泡事件模型， 原始事件模型就是ele.onclick=function(){}这种类型的事件模型 冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document， 捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素） IE是只支持冒泡事件模型的，下面是兼容各个浏览器的事件监听代码 EventUtil={ addListener:function(target,type,handler){ if(target.addEventListener){ target.addEventListener(type,handler); }else if(target.attachEvent){ target.attach(“on”+type,function(){ handler.call(target); //让handler中的this指向目标元素 }); }else{ target[“on”+type]=handler; } }, removeListener:function(target,type,handler){ if(target.removeEventListener){ target.removeEventListener(type,handler); }else if(target.detachEvent){ target.detachEvent(“on”+type,handler); }else{ target[“on”+type]=null; } }, getEvent:function(e){ //获取事件对象 var evt=window.event||e; return evt; }, getTarget:function(e){ //获得目标对象 var evt=EventUtil.getEvent(e); var target; if(evt.target){ target=evt.target;} else {target=evt.srcElement;} return target; }, stopPropagation:function(e){ //停止冒泡 var evt=EventUtil.getEvent(e); if(evt.stopPropagation) {evt.stopPropagation();} else {evt.cancelBubble=true;} }, preventDefault:function(e){ //阻值默认行为的发生 var evt=EventUtil.getEvent(e); if(evt.preventDefault){ evt.preventDefault(); } else {e.returnValue=false;} }}（9）内存泄漏 内存泄漏指的是浏览器不能正常的回收内存的现象 （10）浏览器的垃圾回收机制 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法： 第一，引用计数法 跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。 如： var a = {}; //对象{}的引用计数为1 b = a; //对象{}的引用计数为 1+1 a = null; //对象{}的引用计数为2-1所以这时对象{}不会被回收; IE 6, 7 对DOM对象进行引用计数回收， 这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收， 进行导致内存泄露等问题，一般不用引用计数法。 第二，标记清除法 到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。 （11）同源策略 同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。 （12）跨域的几种方式 jsonp（利用script标签的跨域能力）跨域、websocket（html5的新特性，是一种新协议）跨域、设置代理服务器（由服务器替我们向不同源的服务器请求数据）、CORS（跨源资源共享，cross origin resource sharing）、iframe跨域、postMessage(包含iframe的页面向iframe传递消息)，document.domain跨域（比如：在一个文件中设置了document.domain=”http://qq.com&quot;,那么另一个设置了document.domain=&quot;http://qq.com&quot;的，他们两个就是同源） （13）异步和同步 同步指下一个程序的执行需要等到上一个程序执行完毕，也就是得出结果后下一个才能执行， 异步指的是上一个程序指向后，下一个程序不用等到上一个程序出结果就能执行，等上一个出结果了调用回调函数处理结果就好。 （14）JavaScript的值类型和引用类型 JavaScript有两种类型的数据，值类型和引用类型，一般的数字，字符串，布尔值都是值类型，存放在栈中，而对象，函数，数组等是引用类型，存放在堆中，对引用类型的复制其实是引用复制，相当于复制着地址，对象并没有真正的复制。 var a=5;var b=a;a=null; //那么b是5var a={},var b=a;b.name=”mbj”;console.log(a.name); //mbj，因为a，b指向同一个对象a=null;console.log(typeof b); //object，a=null，只是a不再指向该对象，但是这个对象还是在堆中确确实实的存在，b依然指向它。（15）浏览器js解析引擎的两个队列 请看下面代码 console.log(1); //(1)setTimeout(function(){ console.log(2); //(2)},0)console.log(3); //(3)//输出的结果是1,3,2可能会有人疑问，为什么不是输出1,2,3，这是因为上面代码在执行的时候被放到js解析引擎的同步队列中，然后先执行语句(1),在把setTimeout的回调函数放到异步队列，然后再执行语句(3),这样同步队列里面就没有代码需要执行了，然后在执行异步队列中的回调函数。 浏览器的js解析引擎在解析js代码的时候，把代码放入到两个队列，放入到同步队列中的代码会优先被执行，放入异步队列中的代码等同步队列中的代码被执行完了之后才会执行。需要异步等待回调的代码一般都是放到异步队列中的。 如果能明白下面代码，说明你对setTimeout，异步和同步队列掌握的比较好了 for(var i=1;i&lt;=4;i++){ var time=setTimeout(function(i){ clearTimeout(time); console.log(i); },1000,i);}//输出结果1,2,3//PS:setTimeout的第三个以及第三个后面的参数都是分别传给setTimeout的回调函数的 （16）封装cookie的添加，删除，查询方法 cookie是存储在浏览器端的，可以用于存储sessionID，也可以用于自动登陆，记住密码等，但是在浏览器端并没有官方的操作cookie的方法，下面我们来封装一下： CookieUtil=｛ addCookie:function(key,value,options){ var str=key+”=”+escape(value); if(options.expires){ var curr=new Date(); //options.expires的单位是小时 curr.setTime(curr.getTime()+options.expires36001000); options.expires=curr.toGMTString(); } for(var k in options){ //有可能指定了cookie的path，cookie的domain str+=”;”+k+”=”+options[k]; } document.cookie=str; }, queryCookie:function(key){ var cookies=document.cookie; //获得浏览器端存储的cookie,格式是key=value;key=value;key=value cookies+=”;”; var start=cookies.indexOf(key); if(start&lt;=-1){ return null; } //说明不存在该cookie var end=cookies.indexOf(“;”,start); var value=cookies.slice(start+key.length+1,end); return unescape(value); }, deleteCookie:function(key){ var value=CookieUtil.queryCookie(key); if(value===null){return false;} CookieUtil.addCookie(key,value,{expires:0});//把过期时间设置为0，浏览器会马上自动帮我们删除cookie }｝（17）事件委托机制 事件委托指的是，不再事件的发生地设立监听函数，而是在事件发生地的父元素或者祖先元素设置监听器函数，这样可以大大提高性能，因为可以减少绑定事件的元素，比如： &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;要给li元素绑定click事件，使用事件委托机制的话，就只需要给ul绑定click事件就行了，这样就不需要给每个li’绑定click事件，减小内存占用，提高效率，有兴趣的童鞋可以去看看jQuery的live，bind，on，delegate函数的区别，这几个函数就采用了事件委托机制。 三、其他部分（1）http状态码 http状态码是表示服务器对请求的响应状态，主要分为以下几个部分 1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束 2**：表示请求成功， 3**：表示重定向 4**：表示客户端错误 5**：表示服务器端错误 100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收 200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。 202（Accepted），服务器已接受请求，但尚未处理。 204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容 205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 206（Partial-Content），服务器已经成功处理了部分 GET 请求。 301（Moved-Permanently），永久性重定向 302（Moved-Temporarily），暂时性重定向 304（Not-Modified），浏览器端缓存的资源依然有效 400（Bad-Reques），请求有误，当前请求无法被服务器理解。 401（Unauthorized），当前请求需要用户验证。 403（Forbidden），服务器已经理解请求，但是拒绝执行它。 404（Not-Found），请求的资源没有被找到 500（Interval Server Error），服务器内部错误 502（Bad GateWay），网关出错 503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。 504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 （2）xss，csrf的概念以及防范方法 大公司如bat在面试的时候，web安全问题是必问的问题，所以一定要懂，要彻底理解xss和csrf的概念和防范方式，最好在项目中有用到对这两种攻击的防范，这样会给你的面试加很多分。由xss和csrf涉及的东西比较多，我就不具体给出了，详情请看XSS攻击及防御，CSRF攻击 （3）CommonJs，AMD，CMD规范 对于前端模块化来说，这三个规范是必须要了解的，详情请看我的这篇文章CommonJS，AMD，CMD （4）谈谈对前端模块化的理解 前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范，最后出现了webpack，webpack就是前端模块话的一种解决方案，基本上大公司都会使用webpack，想要详细的学习webpack的话请看webpack简明使用教程 （5）优雅降级和渐进增强 优雅降级指的是一开始就构建功能完好的网站，然后在慢慢兼容低版本的浏览器，使得各个浏览器之间的差异不要太大。 渐进增强是指在基本功能得到满足的情况下，对支持新特性的浏览器使用新特性，带给用户更换的体验。 优雅降级和渐进增强的出发点不同，前者是慢慢向下兼容，是向后看，后着是慢慢向上，增强功能，是向前看。 （6）前端优化（提高网页的加载速度） 1、使用css sprites，可以有效的减少http请求数 2、使用缓存 3、压缩js，css文件，减小文件体积 4、使用cdn，减小服务器负担 5、懒加载图片 6、预加载css，js文件 7、避免dom结构的深层次嵌套 8、给DOM元素添加样式时，把样式放到类中，直接给元素添加类，减少重构，回流 更多详细的前端优化请看前端优化：雅虎35条或者前端性能优化—-yahoo前端性能团队总结的35条黄金定律","tags":[]}]