[{"title":"Angular路由的定义和使用","date":"2017-01-31T16:00:00.000Z","path":"2017/02/01/angular/","text":"一、什么是routing（路由）Almost all non-trivial, non-demo Single Page App (SPA) require multiple pages. A settings page is different from a dashboard view. The login page is different from an accounts page（设置页面不同于控制页面，登录页面不同于账号信息页面。。。。就是说一个应用很多功能不同的页面） 我们可以使用Angular简单优雅地实现这个功能（页面之间的控制跳转…） 二、安装使用angular的路由功能需要安装routing模块…（引入angular-route.js就可以了） 三、定义定义路由非常容易，在我们的应用mian模块里面注入ngRoute依赖就可以了 angular.module(‘myApp’, [‘ngRoute’]) .config(function($routeProvider) {}); 现在，我们就可以给应用定义路由了。在路由模块里面的.config()方法里面注入了$routeProvider，上面的代码给我们演示了两个用于定义路由的方法。 when() when()方法有两个参数，我们希望匹配的浏览器url和路由操作对象。一般main route经常使用“/”来表示，也可以定义URL参数，在controller里面就使用$routeParams获取url参数。 templateUrl: 表示路由跳转的view模板controller: 控制器 angular.module(‘myApp’, [‘ngRoute’]) .config(function($routeProvider) { $routeProvider .when(‘/‘, { templateUrl: ‘views/main.html’, controller: ‘MainCtrl’ }) .when(‘/day/:id’, { templateUrl: ‘views/day.html’, controller: ‘DayCtrl’ })otherwise() otherwise()定义了当应用找不到指定路由的时候跳转的路由 angular.module(‘myApp’, [‘ngRoute’]).config(function($routeProvider) { $routeProvider .when(‘/‘, { templateUrl: ‘views/main.html’, controller: ‘MainCtrl’ }) .when(‘/day/:id’, { templateUrl: ‘views/day.html’, controller: ‘DayCtrl’ }) .otherwise({ redirectTo: ‘/‘ });}) 四、使用定义好了路由需要怎么使用呢?我们要告诉angular页面的哪一个部分是我们希望转换的，这需要使用到ng-view指令 &lt;div class=”header”&amp;gtMy page&lt;/div&gt;&lt;div ng-view&gt;&lt;/div&gt;&lt;span class=”footer”&gt;A footer&lt;/span&gt;” 这样就只有&lt;div ng-view&gt;&lt;/div&gt;会被更新， header/footer都始终保持不变","tags":[]},{"title":"Vue.js为什么不支持templateUrl模式","date":"2016-10-17T16:00:00.000Z","path":"2016/10/18/vue/","text":"这篇文章是翻译的Vue.js的官方blog，最后加了些自己的理解。 原文地址：Why Vue.js doesn’t support templateURL 很多Vue的新手，特别是使用过Angular的都会问“我能不能用 templateURL”,由于回答了太多次了，所以作者决定记下来。 Angular的世界里，templateURL 或者 ng-include 允许使用者在运行时动态的加载远程模板文件，这个看起来很方便，作为一个自带功能，但是让我们来重新审视下这个功能。 首先，它允许我们能够编写一个分离的html文件作为模板，这样子我们就能在编辑的时候看到正确的语法高亮，这也是很多开发者喜欢的原因（注：我觉得这是因为现在的人越来越懒，越来越依赖IDE的原因）。但是分离你的js和html代码真的是个好主意么？在Vue.js的组件中，js和html天然紧耦合，事实上，这些代码在一个文件更简单易懂。在2个文件中来回切换上下文逻辑实际上让开发者更不爽。在vue的概念里，组件才是vue.js的基本构建单位，并不是模板文件。每一个vue.js的模板都伴随着他的好基友js，分离他们太过于残忍了。 其次，因为templateURL是在运行时通过ajax的方式加载模板，不需要构建步骤为了你分离的文件。开发的时候，这很爽，但是上线部署的时候，你就麻烦了。在HTTP2.0没有大面积支持前，HTTP的请求数仍然是页面加载的最关键因素。想象一下，在你的网站中，每个组件都是用templateURL，那么页面出来前，你可能需要加载几十个HTTP请求。可能你并不知道，大多数的浏览器是限制同一域名的并发请求数量的。当你超过这个限额的时候，你页面的初始渲染时间就得等待每次请求的返回。当然，有工具可以帮助你提前注册你所有的模板，但是这就多了一个构建步骤，事实上，这就是大型网站的必然趋势。 那么，在没有templateURL的情况下，我们怎么处理开发环境问题呢？ 在js里面拼接字符串是很烂的做法，使用 &lt;script type=&quot;x/template&quot;&gt;这种伪模板也不咋样。那么，现在是时候提升技能，使用像Webpack或者Browserify这种流行的模块构建器了。如果以前没有使用过，可能有点望而却步，但是相信我，这会有一个质的飞跃。对于大型网站和系统来说，适当的模块化很必要。更重要的是，你可以编写Vue组件在一个文件中，再加上语法高亮，自定义的预处理器，热加载，ES6，内置css，自动前置。可以让开发者提高10倍效率。 最后，Vue还能懒加载你的组件，加上使用wabpack非常容易，尽管这是为了解决一个问—构建页面文件过于庞大，初始化比较慢，所以你最好还是分割开来比较好。 抛弃template，拥抱组件世界吧！！ 以上是原文的翻译，并非完全直译，有很多自己的语言，大概意思相同，原谅我的文采不行。 个人觉得，Vue的组件思想跟React相似，把很多东西放在了js（这里是.vue文件）中，这种做法是把很多紧耦合的东西集中在一起管理，把原来分割开的css,html，js合成在一起，这个很像很多年的做法，所以很同意玉伯说的，看起来前端是在原地打转了一圈，开发模式回到了从前的样子，但是已经螺旋上升了哦，一切都在升级。 通过最近的使用来看，这种component的方式很方便，天然帮你做了解耦的分离，当然你需要转化自己的思维模式，不能在用jquery的操作DOM方式，同时和Angular也有很多区别，Vue并非一个框架，而是更像一个类库，这样很灵活，当然也会有人使用非常hack的方式来编写代码，可能会很蛋疼，这就需要自己注意了，对于团队而言，可以很好的积累各种组件，同时功能切分，合作起来更加容易，就看团队对Vue的理解程度了。","tags":[]},{"title":"前端构建工具gulp入门教程","date":"2016-10-10T16:00:00.000Z","path":"2016/10/11/gulp/","text":"不要怕，它其实很简单，我会分为五步向你介绍gulp并帮助你完成一些惊人的事情。那就直接开始吧。 第一步：安装Node首先，最基本也最重要的是，我们需要搭建node环境。访问 http://nodejs.org ，然后点击大大的绿色的 install 按钮，下载完成后直接运行程序，就一切准备就绪。 npm 会随着安装包一起安装，稍后会用到它。 第二步：使用命令行也许现在你还不是很了解什么是命令行——OSX中的终端（Terminal），windows中的命令提示符（Command Prompt），但很快你就会知道。它看起来没那么简单，但一旦掌握了它的窍门，就可以很方便的执行很多命令行程序，比如Sass，Yeoman和Git等，这些都是非常有用的工具。 如果你很熟悉命令行，直接跳到步骤四。为了确保Node已经正确安装，我们执行几个简单的命令。 node -v回车（Enter），如果正确安装的话，你会看到所安装的Node的版本号，接下来看看npm。 npm -v这同样能得到npm的版本号。 如果这两行命令没有得到返回，可能node就没有安装正确，尝试重启下命令行工具，如果还不行的话，只能回到第一步进行重装。 第三步：定位到项目现在，我们已经大致了解了命令行并且知道如何简单使用它，接下来只需要两个简单的命令就能定位到文件目录并看看目录里都有些什么文件。 cd，定位到目录ls，列出文件列表建议多敲敲这两个命令，了解文件系统并知道文件都在哪里。习惯使用了这两个命令后，就要进入我们的项目目录，这个目录各不相同，举个例子，这是我进入我项目目录的命令： cd /Applications/XAMPP/xamppfiles/htdocs/my-project成功进入项目目录后，我们开始安装gulp。 第四步：安装gulp我们已经知道如何使用命令行，现在尝试点新的东西，认识npm然后安装gulp。 NPM是基于命令行的node包管理工具，它可以将node的程序模块安装到项目中，在它的 官网 中可以查看和搜索所有可用的程序模块。 sudo npm install -g gulpsudo是以管理员身份执行命令，一般会要求输入电脑密码npm是安装node模块的工具，执行install命令 -g表示在全局环境安装，以便任何项目都能使用它 最后，gulp是将要安装的node模块的名字运行时注意查看命令行有没有错误信息，安装完成后，你可以使用下面的命令查看gulp的版本号以确保gulp已经被正确安装。 gulp -v接下来，我们需要将gulp安装到项目本地 npm install —-save-dev gulp这里，我们使用 —-save-dev 来更新package.json文件，更新 devDependencies 值，以表明项目需要依赖gulp。 Dependencies 可以向其他参与项目的人指明项目在开发环境和生产环境中的node模块依懒关系，想要更加深入的了解它可以看看 package.json文档 。 第五步：新建Gulpfile文件，运行gulp安装好gulp后我们需要告诉它要为我们执行哪些任务，首先，我们自己需要弄清楚项目需要哪些任务。 检查Javascript编译Sass（或Less之类的）文件合并Javascript压缩并重命名合并后的Javascript安装依赖 npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename –save-dev提醒下，如果以上命令提示权限错误，需要添加 sudo 再次尝试。新建gulpfile文件 现在，组件都安装完毕，我们需要新建gulpfile文件以指定gulp需要为我们完成什么任务。 gulp只有五个方法： task ， run ， watch ， src ，和 dest ，在项目根目录新建一个js文件并命名为 gulpfile.js ，把下面的代码粘贴进去： gulpfile.js // 引入 gulp var gulp = require(‘gulp’); // 引入组件 var jshint = require(‘gulp-jshint’);var sass = require(‘gulp-sass’);var concat = require(‘gulp-concat’);var uglify = require(‘gulp-uglify’);var rename = require(‘gulp-rename’); // 检查脚本 gulp.task(‘lint’, function() { gulp.src(‘./js/*.js’) .pipe(jshint()) .pipe(jshint.reporter(‘default’));}); // 编译Sass gulp.task(‘sass’, function() { gulp.src(‘./scss/*.scss’) .pipe(sass()) .pipe(gulp.dest(‘./css’));}); // 合并，压缩文件 gulp.task(‘scripts’, function() { gulp.src(‘./js/*.js’) .pipe(concat(‘all.js’)) .pipe(gulp.dest(‘./dist’)) .pipe(rename(‘all.min.js’)) .pipe(uglify()) .pipe(gulp.dest(‘./dist’));}); // 默认任务 gulp.task(‘default’, function(){ gulp.run(‘lint’, ‘sass’, ‘scripts’); // 监听文件变化 gulp.watch(‘./js/*.js’, function(){ gulp.run(‘lint’, ‘sass’, ‘scripts’); });});现在，分段解释下这段代码。 引入组件 var gulp = require(‘gulp’);var jshint = require(‘gulp-jshint’);var sass = require(‘gulp-sass’);var concat = require(‘gulp-concat’);var uglify = require(‘gulp-uglify’);var rename = require(‘gulp-rename’);这一步，我们引入了核心的gulp和其他依赖组件，接下来，分开创建lint, sass, scripts 和 default这四个不同的任务。 Lint任务 gulp.task(‘lint’, function() { gulp.src(‘./js/*.js’) .pipe(jshint()) .pipe(jshint.reporter(‘default’));});Link任务会检查 js/ 目录下得js文件有没有报错或警告。 Sass任务 gulp.task(‘sass’, function() { gulp.src(‘./scss/*.scss’) .pipe(sass()) .pipe(gulp.dest(‘./css’));});Sass任务会编译 scss/ 目录下的scss文件，并把编译完成的css文件保存到 /css 目录中。 Scripts 任务 gulp.task(‘scripts’, function() { gulp.src(‘./js/*.js’) .pipe(concat(‘all.js’)) .pipe(gulp.dest(‘./dist’)) .pipe(rename(‘all.min.js’)) .pipe(uglify()) .pipe(gulp.dest(‘./dist’));});scripts任务会合并 js/ 目录下得所有得js文件并输出到 dist/ 目录，然后gulp会重命名、压缩合并的文件，也输出到 dist/ 目录。 default任务 gulp.task(‘default’, function(){ gulp.run(‘lint’, ‘sass’, ‘scripts’); gulp.watch(‘./js/*.js’, function(){ gulp.run(‘lint’, ‘sass’, ‘scripts’); });});这时，我们创建了一个基于其他任务的default任务。使用 .run() 方法关联和运行我们上面定义的任务，使用 .watch() 方法去监听指定目录的文件变化，当有文件变化时，会运行回调定义的其他任务。 现在，回到命令行，可以直接运行gulp任务了。 gulp这将执行定义的default任务，换言之，这和以下的命令式同一个意思 gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在运行sass任务： gulp sass","tags":[]},{"title":"Css3 和 H5 新特性","date":"2016-09-12T16:00:00.000Z","path":"2016/09/13/css3/","text":"Html5 绘画 canvas 元素 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、searchCSS3 CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 是IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式： 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架","tags":[]},{"title":"JavaScript 模块化入门Ⅰ：理解模块","date":"2015-12-17T16:00:00.000Z","path":"2015/12/18/model3/","text":"原文链接：JavaScript Modules: A Beginner’s Guide 作者：Preethi Kasireddy 作为一名JS初学者。假如你听到了一些诸如“模块化构建&amp;模块化载入” “Webpack&amp;Browserify” 或者 “AMD&amp;CMD”之类的术语，肯定瞬间就凌乱了。 JavaScript的模块化听起来挺深奥，可其实理解它对开发者来说特别实用。 在这篇文章里，我会尽量深入浅出地把这些深奥的术语翻译成浅显易懂的人话（加上一些代码示例）。希望你多少能从中学到点东西。为了避免长篇大论，整个内容会分为两篇文章，这是第一部分，主要介绍模块化是什么，为什么要使用模块。之后的第二部分会介绍如何打包JS模块，以及各类构建工具。 求解释到底什么是模块化称职的作家会把他的书分章节和段落；好的程序员会把他的代码分成模块。 就好像书籍的一章，模块仅仅是一坨代码而已。 好的代码模块分割的内容一定是很合理的，便于你增加减少或者修改功能，同时又不会影响整个系统。 为什么要使用模块模块化可以使你的代码低耦合，功能模块直接不相互影响。我个人认为模块化主要有以下几点好处： 1.可维护性：根据定义，每个模块都是独立的。良好设计的模块会尽量与外部的代码撇清关系，以便于独立对其进行改进和维护。维护一个独立的模块比起一团凌乱的代码来说要轻松很多。 2.命名空间：在JavaScript中，最高级别的函数外定义的变量都是全局变量（这意味着所有人都可以访问到它们）。也正因如此，当一些无关的代码碰巧使用到同名变量的时候，我们就会遇到“命名空间污染”的问题。 这样的问题在我们开发过程中是要极力避免的。 后面的内容里我也会举一些具体的例子来说明这一点。 3.可复用性：现实来讲，在日常工作中我们经常会复制自己之前写过的代码到新项目中。 复制粘贴虽然很快很方便，但难道我们找不到更好的办法了么？要是……有一个可以重复利用的模块岂不妙哉？ 如何引入模块引入模块有很多种方式，这里我们先介绍一些： 模块模式 模块模式一般用来模拟类的概念（因为原生JavaScript并不支持类，虽然最新的ES6里引入了Class不过还不普及）这样我们就能把公有和私有方法还有变量存储在一个对象中——这就和我们在Java或Python里使用类的感觉一样。这样我们就能在公开调用API的同时，仍然在一个闭包范围内封装私有变量和方法。 实现模块模式的方法有很多种，下面的例子是通过匿名闭包函数的方法。（在JavaScript中，函数是创建作用域的唯一方式。） 例1：匿名闭包函数// 在函数的作用域中下面的变量是私有的123456789101112131415161718192021(function () &#123; var myGrades = [93, 95, 88, 0, 55, 91]; var average = function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item&#125;, 0); return &apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125; var failing = function()&#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70;&#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125; console.log(failing());&#125;()); // 控制台显示：’You failed 2 times.’通过这种构造，我们的匿名函数有了自己的作用域或“闭包”。 这允许我们从父（全局）命名空间隐藏变量。 这种方法的好处在于，你可以在函数内部使用局部变量，而不会意外覆盖同名全局变量，但仍然能够访问到全局变量，如下所示： 123456789101112131415161718192021222324var global = &apos;Hello, I am a global variable :)&apos;;(function () &#123; // 在函数的作用域中下面的变量是私有的 var myGrades = [93, 95, 88, 0, 55, 91]; var average = function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item&#125;, 0); return &apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125; var failing = function()&#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70;&#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125; console.log(failing()); console.log(global);&#125;()); // 控制台显示：’You failed 2 times.’// 控制台显示：’Hello, I am a global variable :)’要注意的是，一定要用括号把匿名函数包起来，以关键词function开头的语句总是会被解释成函数声明（JS中不允许没有命名的函数声明），而加上括号后，内部的代码就会被识别为函数表达式。其实这个也叫作立即执行函数（IIFE）感兴趣的同学可以在这里了解更多 例2：全局引入另一种比较受欢迎的方法是一些诸如jQuery的库使用的全局引入。和我们刚才举例的匿名闭包函数很相似，只是传入全局变量的方法不同： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657(function (globalVariable) &#123; // 在函数的作用域中下面的变量是私有的 var privateFunction = function() &#123; console.log(&apos;Shhhh, this is private!&apos;); &#125; // 通过全局变量设置下列方法的外部访问接口 // 与此同时这些方法又都在函数内部 globalVariable.each = function(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;; globalVariable.filter = function(collection, test) &#123; var filtered = []; globalVariable.each(collection, function(item) &#123; if (test(item)) &#123; filtered.push(item); &#125; &#125;); return filtered; &#125;; globalVariable.map = function(collection, iterator) &#123; var mapped = []; globalUtils.each(collection, function(value, key, collection) &#123; mapped.push(iterator(value)); &#125;); return mapped; &#125;; globalVariable.reduce = function(collection, iterator, accumulator) &#123; var startingValueMissing = accumulator === undefined; globalVariable.each(collection, function(item) &#123; if(startingValueMissing) &#123; accumulator = item; startingValueMissing = false; &#125; else &#123; accumulator = iterator(accumulator, item); &#125; &#125;); return accumulator; &#125;; &#125;(globalVariable)); 在这个例子中，globalVariable 是唯一的全局变量。这种方法的好处是可以预先声明好全局变量，让你的代码更加清晰可读。 例3：对象接口像下面这样，还有一种创建模块的方法是使用独立的对象接口： 123456789101112131415161718192021222324252627282930var myGradesCalculate = (function () &#123; // 在函数的作用域中下面的变量是私有的 var myGrades = [93, 95, 88, 0, 55, 91]; // 通过接口在外部访问下列方法 // 与此同时这些方法又都在函数内部 return &#123; average: function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item; &#125;, 0); return&apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125;, failing: function() &#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70; &#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125; &#125;&#125;)();myGradesCalculate.failing(); // &apos;You failed 2 times.&apos; myGradesCalculate.average(); // &apos;Your average grade is 70.33333333333333.&apos; 例4：揭示模块模式 Revealing module pattern这和我们之前的实现方法非常相近，除了它会确保，在所有的变量和方法暴露之前都会保持私有： 12345678910111213141516171819202122232425262728293031var myGradesCalculate = (function () &#123; // 在函数的作用域中下面的变量是私有的 var myGrades = [93, 95, 88, 0, 55, 91]; var average = function() &#123; var total = myGrades.reduce(function(accumulator, item) &#123; return accumulator + item; &#125;, 0); return&apos;Your average grade is &apos; + total / myGrades.length + &apos;.&apos;; &#125;; var failing = function() &#123; var failingGrades = myGrades.filter(function(item) &#123; return item &lt; 70; &#125;); return &apos;You failed &apos; + failingGrades.length + &apos; times.&apos;; &#125;; // 将公有指针指向私有方法 return &#123; average: average, failing: failing &#125;&#125;)();myGradesCalculate.failing(); // &apos;You failed 2 times.&apos; myGradesCalculate.average(); // &apos;Your average grade is 70.33333333333333.&apos; 到这里，其实我们只聊了模块模式的冰山一角。感兴趣的朋友可以阅读更详细的资料： 深入理解JavaScript 模块模式深入理解JavaScript系列（3）：全面解析Module模式 CommonJS &amp; AMD上述的所有解决方案都有一个共同点：使用单个全局变量来把所有的代码包含在一个函数内，由此来创建私有的命名空间和闭包作用域。 虽然每种方法都比较有效，但也都有各自的短板。 有一点，作为开发者，你必须清楚地了解引入依赖文件的正确顺序。就拿Backbone.js来举个例子，想要使用Backbone就必须在你的页面里引入Backbone的源文件。 然而Backbone又依赖 Underscore.js，所以Backbone的引入必须在其之后。 而在工作中，这些依赖管理经常会成为让人头疼的问题。 另外一点，这些方法也有可能引起命名空间冲突。举个例子，要是你碰巧写了俩重名的模块怎么办？或者你同时需要一个模块的两个版本时该怎么办？ 难道就没有不通过全局作用域来实现的模块方法么？ 当然是有的。 接下来介绍两种广受欢迎的解决方案：CommonJS 和 AMD. CommonJSCommonJS 扩展了JavaScript声明模块的API. CommonJS模块可以很方便得将某个对象导出，让他们能够被其他模块通过 require 语句来引入。要是你写过 Node.js 应该很熟悉这些语法。 通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入。 还是举个直观的例子吧： 1234567891011function myModule() &#123; this.hello = function() &#123; return &apos;hello!&apos;; &#125; this.goodbye = function() &#123; return &apos;goodbye!&apos;; &#125;&#125;module.exports = myModule; 通过指定导出的对象名称，CommonJS模块系统可以识别在其他文件引入这个模块时应该如何解释。 然后在某个人想要调用 myMoudle 的时候，只需要 require 一下： 12345var myModule = require(&apos;myModule&apos;);var myModuleInstance = new myModule();myModuleInstance.hello(); // &apos;hello!&apos;myModuleInstance.goodbye(); // &apos;goodbye!&apos; 这种实现比起模块模式有两点好处： 避免全局命名空间污染明确代码之间的依赖关系并且这种书写方式也非常舒服友好，我自己很喜欢。 需要注意的一点是，CommonJS以服务器优先的方式来同步载入模块，假使我们引入三个模块的话，他们会一个个地被载入。 它在服务器端用起来很爽，可是在浏览器里就不会那么高效了。毕竟读取网络的文件要比本地耗费更多时间。只要它还在读取模块，浏览器载入的页面就会一直卡着不动。（在下一篇第二部分的教程里我们会讨论如何解决这个问题） AMDCommonJS已经挺不错了，但假使我们想要实现异步加载模块该怎么办？答案就是Asynchronous Module Definition（异步模块定义规范），简称AMD. 通过AMD载入模块的代码一般这么写：123define([&apos;myModule&apos;, &apos;myOtherModule&apos;], function(myModule, myOtherModule) &#123; console.log(myModule.hello());&#125;); 这里我们使用 define 方法，第一个参数是依赖的模块，这些模块都会在后台无阻塞地加载，第二个参数则作为加载完毕的回调函数。 回调函数将会使用载入的模块作为参数。在这个例子里就是 myMoudle 和 myOtherModule.最后，这些模块本身也需要通过 define 关键词来定义。 拿 myModule 来举个例子： 1234567891011define([], function() &#123; return &#123; hello: function() &#123; console.log(&apos;hello&apos;); &#125;, goodbye: function() &#123; console.log(&apos;goodbye&apos;); &#125; &#125;;&#125;); 重申一下，不像CommonJS，AMD是优先浏览器的一种异步载入模块的解决方案。（记得，很多人认为一个个地载入小文件是很低效的，我们将在下一篇文章理介绍如何打包模块） 除了异步加载以外，AMD的另一个优点是你可以在模块里使用对象、函数、构造函数、字符串、JSON或者别的数据类型，而CommonJS只支持对象。 再补充一点，AMD不支持Node里的一些诸如 IO,文件系统等其他服务器端的功能。另外语法上写起来也比CommonJS麻烦一些。 UMD在一些同时需要AMD和CommonJS功能的项目中，你需要使用另一种规范：Universal Module Definition（通用模块定义规范）。 UMD创造了一种同时使用两种规范的方法，并且也支持全局变量定义。所以UMD的模块可以同时在客户端和服务端使用。 下面是一个解释其功能的例子：1234567891011121314151617181920212223(function (root, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; // AMD define([&apos;myModule&apos;, &apos;myOtherModule&apos;], factory); &#125; else if (typeof exports === &apos;object&apos;) &#123; // CommonJS module.exports = factory(require(&apos;myModule&apos;), require(&apos;myOtherModule&apos;)); &#125; else &#123; // Browser globals (Note: root is window) root.returnExports = factory(root.myModule, root.myOtherModule); &#125;&#125;(this, function (myModule, myOtherModule) &#123; // Methods function notHelloOrGoodbye()&#123;&#125;; // A private method function hello()&#123;&#125;; // A public method because it&apos;s returned (see below) function goodbye()&#123;&#125;; // A public method because it&apos;s returned (see below) // Exposed public methods return &#123; hello: hello, goodbye: goodbye &#125;&#125;)); 更多有关UMD的例子请看其Github上的官方repo. 原生JS希望你坚持读到了现在，我们最后再介绍一种定义模块的方式。 你可能注意到了，上述的这几种方法都不是JS原生支持的。要么是通过模块模式来模拟，要么是使用CommonJS或AMD. 幸运的是在JS的最新规范ECMAScript 6 (ES6)中，引入了模块功能。 ES6 的模块功能汲取了CommonJS 和 AMD 的优点，拥有简洁的语法并支持异步加载，并且还有其他诸多更好的支持。 我最喜欢的ES6 模块功能的特性是，导入是实时只读的。（CommonJS 只是相当于把导出的代码复制过来）。 来看例子：12345678910111213141516171819202122232425// lib/counter.jsvar counter = 1;function increment() &#123; counter++;&#125;function decrement() &#123; counter--;&#125;module.exports = &#123; counter: counter, increment: increment, decrement: decrement&#125;;// src/main.jsvar counter = require(&apos;../../lib/counter&apos;);counter.increment();console.log(counter.counter); // 1 上面这个例子中，我们一共创建了两份模块的实例，一个在导出的时候，一个在引入的时候。 在 main.js 当中的实例是和原本模块完全不相干的。这也就解释了为什么调用了 counter.increment() 之后仍然返回1。因为我们引入的 counter 变量和模块里的是两个不同的实例。 所以调用 counter.increment() 方法只会改变模块中的 counter .想要修改引入的 counter 只有手动一下啦：12345678910111213141516171819202122counter.counter++;console.log(counter.counter); // 2//而通过 import 语句，可以引入实时只读的模块：// lib/counter.jsexport let counter = 1;export function increment() &#123; counter++;&#125;export function decrement() &#123; counter--;&#125;// src/main.jsimport * as counter from &apos;../../counter&apos;;console.log(counter.counter); // 1counter.increment();console.log(counter.counter); // 2 这看起来很酷不是么？这样就实现了我们把模块分隔在不同的文件里，需要的时候又可以合并在一起而且不影响它的功能。 我想看到这里的你应该已经对JavaScript模块化有了进一步的了解。","tags":[]},{"title":"前端面试知识点总结","date":"2015-09-30T16:00:00.000Z","path":"2015/10/01/mianshi1/","text":"一、html+css部分（1）css盒模型，可能会要求手写一个布局，这个布局基本上用到的css是margin的负值，boxing-sizing：border-box，布局尽量往这方面想。浏览器布局的基本元素是盒，在w3c的标准模式下，width=width，但是在怪异模式下，width=border2+padding2+width;其中后代元素的width：100%；参照的是右边的那个width， （2）html5的新特性 1、标签语义化，比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签2、音视频元素，video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。 3、新增很多api，比如获取用户地理位置的window.navigator.geoloaction， 4、websocket websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端， 5、webstorage，webstorage是本地存储，存储在客户端，包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了， 6、缓存 html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下： 1、首先给html添加manifest属性，并赋值为cache.manifest2、cache.manifest的内容为: CACHE MANIFEST #v1.2 CACHE : //表示需要缓存的文件 a.js b.js NETWORK: //表示只在用户在线的时候才需要的文件，不会缓存 c.js FALLBACK / /index.html //表示如果找不到第一个资源就用第二个资源代替 7、web worker，web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。 （3）对html5的语义话的理解 html5的语义化指的是用正确的标签包含正确的内容，比如nav标签，里面就应该包含导航条的内容，而不是用做其他的用途，标签语义化的好处就是结构良好，便于阅读，方便威化，也有利于爬虫的查找，提高搜索率。 （4）cookie，sessionStorage，localeStorage的区别 cookie是存储在浏览器端，并且随浏览器的请求一起发送到服务器端的，它有一定的过期时间，到了过期时间自动会消失。sessionStorage和localeStorage也是存储在客户端的，同属于web Storage，比cookie的存储大小要大有8m，cookie只有4kb，localeStorage是持久化的存储在客户端，如果用户不手动清除的话，不会自动消失，会一直存在，sessionStorage也是存储在客户端，但是它的存活时间是在一个回话期间，只要浏览器的回话关闭了就会自动消失。 （5）多个页面之间如何进行通信 使用cookie，使用web worker，使用localeStorage和sessionStorage （6）浏览器的渲染过程 1、首先获取html，然后构建dom树 2、其次根据css构建render树，render树中不包含定位和几何信息 3、最后构建布局数，布局是含有元素的定位和几何信息 （7）重构、回流 浏览器的重构指的是改变每个元素外观时所触发的浏览器行为，比如颜色，背景等样式发生了改变而进行的重新构造新外观的过程。重构不会引发页面的重新布局，不一定伴随着回流， 回流指的是浏览器为了重新渲染页面的需要而进行的重新计算元素的几何大小和位置的，他的开销是非常大的，回流可以理解为渲染树需要重新进行计算，一般最好触发元素的重构，避免元素的回流；比如通过通过添加类来添加css样式，而不是直接在DOM上设置，当需要操作某一块元素时候，最好使其脱离文档流，这样就不会引起回流了，比如设置position：absolute或者fixed，或者display：none，等操作结束后在显示。 二、JavaScript部分（1）JavaScript的数据类型 基本数据类型：Number，String，Boolean，Undefined，Null 复杂数据类型：Object，Array，Function，RegExp，Date，Error 全局数据类型：Math （2）JavaScript的闭包 闭包简单的说就是一个函数能访问外部函数的变量，这就是闭包，比如说： function a(x){ var tem=3; function b(y){ console.log(x+y+(++tem)); }}a函数中的b函数就是闭包了，b函数可以使用a函数的局部变量，参数，最典型的闭包应该是下面这样，将定义在函数中的函数作为返回值 function a(x){ var tem=3; function b(y){ console.log(x+y+(++tem)); }return b;}闭包的缺点是，因为内部闭包函数可以访问外部函数的变量，所以外部函数的变量不能被释放，如果闭包嵌套过多，会导致内存占用大，要合理使用闭包。 （3）new 操作符到底做了什么 首先，new操作符为我们创建一个新的空对象，然后this变量指向该对象， 其次，空对象的原型执行函数的原型， 最后，改变构造函数内部的this的指向 代码如下： var obj={};obj.proto=fn.prototype;fn.call(obj);（4）改变函数内部this指针的指向函数 call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);那么问题来了，call和apply的区别是什么，其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。还有一个bind函数， var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内的this指针指向obj对象。 （5）JavaScript的作用域和作用域链 JavaScript的作用域指的是变量的作用范围，内部作用域由函数的形参，实参，局部变量，函数构成，内部作用域和外部的作用域一层层的链接起来形成作用域链，当在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到外部的作用域中去查找，还是没有的话，就到在外面一层作用域中找，直到到window所在的作用域，每个函数在声明的时候就默认有一个外部作用域链存在了，比如： var t=4;function foo(){ var tem=12; funciton bar(){ var temo=34; console.log(t+” “+tem+” “+temo); }}在bar函数中找t变量的过程就是，先到自己的内部作用域中找，发现没有找到，然后到bar所在的最近的外部环境中找，也就是foo的内部作用域，还是没有找到，再到window的作用域中找，结果找到了 （6）JavaScript的继承 function A(name){ this.name=name; }A.prototype.sayName=function(){ console.log(this.name); }function B(age){ this.age=age; }原型继承 B.prototype=new A(“mbj”); //被B的实例共享var foo=new B(18);foo.age; //18,age是本身携带的属性foo.name; //mbj，等价于foo.proto.namefoo.sayName(); //mbj,等价于foo.proto.proto.sayName()foo.toString(); //“[object Object]”,等价于foo.proto.proto.proto.toString();这样B通过原型继承了A，在new B的时候，foo中有个隐藏的属性proto指向构造函数的prototype对象，在这里是A对象实例，A对象里面也有一个隐藏的属性proto,指向A构造函数的prototype对象，这个对象里面又有一个proto__指向Object的prototype 这种方式的缺第一个缺点是所有子类共享父类实例，如果某一个子类修改了父类，其他的子类在继承的时候，会造成意想不到的后果。第二个缺点是在构造子类实例的时候，不能给父类传递参数。 构造函数继承 function B(age,name){ this.age=age;A.call(this,name); }var foo=new B(18,”wmy”);foo.name; //wmyfoo.age; //18foo.sayName(); //undefined采用这种方式继承是把A中的属性加到this上面，这样name相当于就是B的属性，sayName不在A的构造函数中，所以访问不到sayName。这种方法的缺点是父类的prototype中的函数不能复用。 原型继承+构造函数继承 function B(age,name){ this.age=age;A.call(this,name); }B.prototype=new A(“mbj”);var foo=new B(18,”wmy”);foo.name; //wmyfoo.age; //18foo.sayName(); //wmy这样就可以成功访问sayName函数了，结合了上述两种方式的优点，但是这种方式也有缺点，那就是占用的空间更大了。 （7）JavaScript变量提升 请看下面代码 var bar=1;function test(){ console.log(bar); //undeifned var bar=2; console.log(bar); //2}test();为什么在test函数中会出现上述结果呢，这就是JavaScript的变量提升了，虽然变量bar的定义在后面，不过浏览器在解析的时候，会把变量的定义放到最前面，上面的test函数相当于 function test(){ var bar; console.log(bar); //undefined bar=2; console.log(bar); //2}再看 var foo=function(){ console.log(1); }function foo(){ console.log(2); }foo(); //结果为1同样的，函数的定义也会到提升到最前面，上面的代码相当于function foo(){ console.log(2); }var foo;foo=funciton(){ console.log(1); }foo(); //1（8）JavaScript事件模型 原始事件模型，捕获型事件模型，冒泡事件模型， 原始事件模型就是ele.onclick=function(){}这种类型的事件模型 冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document， 捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素） IE是只支持冒泡事件模型的，下面是兼容各个浏览器的事件监听代码 EventUtil={ addListener:function(target,type,handler){ if(target.addEventListener){ target.addEventListener(type,handler); }else if(target.attachEvent){ target.attach(“on”+type,function(){ handler.call(target); //让handler中的this指向目标元素 }); }else{ target[“on”+type]=handler; } }, removeListener:function(target,type,handler){ if(target.removeEventListener){ target.removeEventListener(type,handler); }else if(target.detachEvent){ target.detachEvent(“on”+type,handler); }else{ target[“on”+type]=null; } }, getEvent:function(e){ //获取事件对象 var evt=window.event||e; return evt; }, getTarget:function(e){ //获得目标对象 var evt=EventUtil.getEvent(e); var target; if(evt.target){ target=evt.target;} else {target=evt.srcElement;} return target; }, stopPropagation:function(e){ //停止冒泡 var evt=EventUtil.getEvent(e); if(evt.stopPropagation) {evt.stopPropagation();} else {evt.cancelBubble=true;} }, preventDefault:function(e){ //阻值默认行为的发生 var evt=EventUtil.getEvent(e); if(evt.preventDefault){ evt.preventDefault(); } else {e.returnValue=false;} }}（9）内存泄漏 内存泄漏指的是浏览器不能正常的回收内存的现象 （10）浏览器的垃圾回收机制 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法： 第一，引用计数法 跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。 如： var a = {}; //对象{}的引用计数为1 b = a; //对象{}的引用计数为 1+1 a = null; //对象{}的引用计数为2-1所以这时对象{}不会被回收; IE 6, 7 对DOM对象进行引用计数回收， 这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收， 进行导致内存泄露等问题，一般不用引用计数法。 第二，标记清除法 到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。 （11）同源策略 同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。 （12）跨域的几种方式 jsonp（利用script标签的跨域能力）跨域、websocket（html5的新特性，是一种新协议）跨域、设置代理服务器（由服务器替我们向不同源的服务器请求数据）、CORS（跨源资源共享，cross origin resource sharing）、iframe跨域、postMessage(包含iframe的页面向iframe传递消息)，document.domain跨域（比如：在一个文件中设置了document.domain=”http://qq.com&quot;,那么另一个设置了document.domain=&quot;http://qq.com&quot;的，他们两个就是同源） （13）异步和同步 同步指下一个程序的执行需要等到上一个程序执行完毕，也就是得出结果后下一个才能执行， 异步指的是上一个程序指向后，下一个程序不用等到上一个程序出结果就能执行，等上一个出结果了调用回调函数处理结果就好。 （14）JavaScript的值类型和引用类型 JavaScript有两种类型的数据，值类型和引用类型，一般的数字，字符串，布尔值都是值类型，存放在栈中，而对象，函数，数组等是引用类型，存放在堆中，对引用类型的复制其实是引用复制，相当于复制着地址，对象并没有真正的复制。 var a=5;var b=a;a=null; //那么b是5var a={},var b=a;b.name=”mbj”;console.log(a.name); //mbj，因为a，b指向同一个对象a=null;console.log(typeof b); //object，a=null，只是a不再指向该对象，但是这个对象还是在堆中确确实实的存在，b依然指向它。（15）浏览器js解析引擎的两个队列 请看下面代码 console.log(1); //(1)setTimeout(function(){ console.log(2); //(2)},0)console.log(3); //(3)//输出的结果是1,3,2可能会有人疑问，为什么不是输出1,2,3，这是因为上面代码在执行的时候被放到js解析引擎的同步队列中，然后先执行语句(1),在把setTimeout的回调函数放到异步队列，然后再执行语句(3),这样同步队列里面就没有代码需要执行了，然后在执行异步队列中的回调函数。 浏览器的js解析引擎在解析js代码的时候，把代码放入到两个队列，放入到同步队列中的代码会优先被执行，放入异步队列中的代码等同步队列中的代码被执行完了之后才会执行。需要异步等待回调的代码一般都是放到异步队列中的。 如果能明白下面代码，说明你对setTimeout，异步和同步队列掌握的比较好了 for(var i=1;i&lt;=4;i++){ var time=setTimeout(function(i){ clearTimeout(time); console.log(i); },1000,i);}//输出结果1,2,3//PS:setTimeout的第三个以及第三个后面的参数都是分别传给setTimeout的回调函数的 （16）封装cookie的添加，删除，查询方法 cookie是存储在浏览器端的，可以用于存储sessionID，也可以用于自动登陆，记住密码等，但是在浏览器端并没有官方的操作cookie的方法，下面我们来封装一下： CookieUtil=｛ addCookie:function(key,value,options){ var str=key+”=”+escape(value); if(options.expires){ var curr=new Date(); //options.expires的单位是小时 curr.setTime(curr.getTime()+options.expires36001000); options.expires=curr.toGMTString(); } for(var k in options){ //有可能指定了cookie的path，cookie的domain str+=”;”+k+”=”+options[k]; } document.cookie=str; }, queryCookie:function(key){ var cookies=document.cookie; //获得浏览器端存储的cookie,格式是key=value;key=value;key=value cookies+=”;”; var start=cookies.indexOf(key); if(start&lt;=-1){ return null; } //说明不存在该cookie var end=cookies.indexOf(“;”,start); var value=cookies.slice(start+key.length+1,end); return unescape(value); }, deleteCookie:function(key){ var value=CookieUtil.queryCookie(key); if(value===null){return false;} CookieUtil.addCookie(key,value,{expires:0});//把过期时间设置为0，浏览器会马上自动帮我们删除cookie }｝（17）事件委托机制 事件委托指的是，不再事件的发生地设立监听函数，而是在事件发生地的父元素或者祖先元素设置监听器函数，这样可以大大提高性能，因为可以减少绑定事件的元素，比如： &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;要给li元素绑定click事件，使用事件委托机制的话，就只需要给ul绑定click事件就行了，这样就不需要给每个li’绑定click事件，减小内存占用，提高效率，有兴趣的童鞋可以去看看jQuery的live，bind，on，delegate函数的区别，这几个函数就采用了事件委托机制。 三、其他部分（1）http状态码 http状态码是表示服务器对请求的响应状态，主要分为以下几个部分 1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束 2**：表示请求成功， 3**：表示重定向 4**：表示客户端错误 5**：表示服务器端错误 100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收 200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。 202（Accepted），服务器已接受请求，但尚未处理。 204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容 205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 206（Partial-Content），服务器已经成功处理了部分 GET 请求。 301（Moved-Permanently），永久性重定向 302（Moved-Temporarily），暂时性重定向 304（Not-Modified），浏览器端缓存的资源依然有效 400（Bad-Reques），请求有误，当前请求无法被服务器理解。 401（Unauthorized），当前请求需要用户验证。 403（Forbidden），服务器已经理解请求，但是拒绝执行它。 404（Not-Found），请求的资源没有被找到 500（Interval Server Error），服务器内部错误 502（Bad GateWay），网关出错 503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。 504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 （2）xss，csrf的概念以及防范方法 大公司如bat在面试的时候，web安全问题是必问的问题，所以一定要懂，要彻底理解xss和csrf的概念和防范方式，最好在项目中有用到对这两种攻击的防范，这样会给你的面试加很多分。由xss和csrf涉及的东西比较多，我就不具体给出了，详情请看XSS攻击及防御，CSRF攻击 （3）CommonJs，AMD，CMD规范 对于前端模块化来说，这三个规范是必须要了解的，详情请看我的这篇文章CommonJS，AMD，CMD （4）谈谈对前端模块化的理解 前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范，最后出现了webpack，webpack就是前端模块话的一种解决方案，基本上大公司都会使用webpack，想要详细的学习webpack的话请看webpack简明使用教程 （5）优雅降级和渐进增强 优雅降级指的是一开始就构建功能完好的网站，然后在慢慢兼容低版本的浏览器，使得各个浏览器之间的差异不要太大。 渐进增强是指在基本功能得到满足的情况下，对支持新特性的浏览器使用新特性，带给用户更换的体验。 优雅降级和渐进增强的出发点不同，前者是慢慢向下兼容，是向后看，后着是慢慢向上，增强功能，是向前看。 （6）前端优化（提高网页的加载速度） 1、使用css sprites，可以有效的减少http请求数 2、使用缓存 3、压缩js，css文件，减小文件体积 4、使用cdn，减小服务器负担 5、懒加载图片 6、预加载css，js文件 7、避免dom结构的深层次嵌套 8、给DOM元素添加样式时，把样式放到类中，直接给元素添加类，减少重构，回流 更多详细的前端优化请看前端优化：雅虎35条或者前端性能优化—-yahoo前端性能团队总结的35条黄金定律","tags":[]},{"title":"JavaScript 模块化入门Ⅱ：模块打包构建","date":"2015-08-17T16:00:00.000Z","path":"2015/08/18/model4/","text":"原文链接：JavaScript Modules Part 2: Module Bundling作者：Preethi Kasireddy 在上一篇教程里我们已经讨论过什么是模块，为什么要使用模块以及多种实现模块化的方式。 这次，我们会聊一聊什么是模块打包，为什么要打包模块，模块打包的方式工具，还有它当前在Web开发中的运用。 什么是模块打包？粗俗一点来讲，模块打包就是把一小坨一小坨的代码粘成一大坨。 实际操作起来的时候当然还需要关注一些细节。 为什么要打包模块？一般来讲，我们用模块化组织代码的时候，都会把模块划分在不同的文件和文件夹里，也可能会包含一些诸如React和Underscore一类的第三方库。 而后，所有的这些模块都需要通过&lt;script&gt;标签引入到你的HTML文件中，然后用户在访问你网页的时候它才能正常显示和工作。每个独立的&lt;script&gt;标签都意味着，它们要被浏览器分别一个个地加载。 这就有可能导致页面载入时间过长。 为了解决这个问题，我们就需要进行模块打包，把所有的模块合并到一个或几个文件中，以此来减少HTTP请求数。这也可以被称作是从开发到上线前的构建环节。 还有一种提升加载速度的做法叫做代码压缩（混淆）。其实就是去除代码中不必要的空格、注释、换行符一类的字符，来保证在不影响代码正常工作的情况下压缩其体积。 更小的文件体积也就意味着更短的加载时间。要是你仔细对比过带有 .min后缀的例如 jquery.min.js和jquery.js的话，应该会发现压缩版的文件相较之下要小很多。 Gulp和Grunt一类的构建工具可以很方便地解决上述的需求，在开发的时候通过模块来组织代码，上线时再合并压缩提供给浏览器。 打包模块的方法有哪些？如果你的代码是通过之前介绍过的模块模式来组织的，合并和压缩它们其实就只是把一些原生的JS代码合在一起而已。 但如果你使用的是一些浏览器原生不支持的模块系统（例如CommonJS 或 AMD，以及ES6 模块的支持现在也不完整），你就需要使用一些专门的构建工具来把它们转换成浏览器支持的代码。这类工具就是我们最近经常听说的Browserify, RequireJS, Webpack等等模块化构建、模块化加载工具了。 为了实现模块化构建或载入的功能，这类工具提供许多诸如在你改动源代码后自动重新构建（文件监听）等一系列的功能。 下面我们就一起来看一些实际的例子吧： 打包 CommonJS在上一篇教程中我们了解到， CommonJS是同步载入模块的，这对浏览器来说不是很理想。其实下面介绍的模块化构建工具Browserify在上一篇也提到过。它是一个专门用来打包CommonJS模块以便在浏览器里运行的构建工具。 举个例子，假如你在 main.js 文件中引入了一个用来计算平均数的功能模块：12345var myDependency = require(&apos;myDependency&apos;);var myGrades = [93, 95, 88, 0, 91];var myAverageGrade = myDependency.average(myGrades); 在这个示例中，我们只有一个名为 myDependency 的模块依赖。通过下面的命令，Browserify会依次把main.js里引入的所有模块一同打包到一个名为 bundle.js 的文件里： browserify main.js -o bundle.jsBrowserify 首先会通过抽象语法树（AST）来解析代码中的每一个 require 语句，在分析完所有模块的依赖和结构之后，就会把所有的代码合并到一个文件中。然后你在HTML文件里引入一个bundle.js就够啦。 多个文件和多个依赖也只需要再稍微配置一下就能正常工作了。 之后你也可以使用一些例如MinifyJS的工具来压缩代码。 打包 AMD假若你使用的是AMD，你会需要一些例如RequireJS 或 Curl的AMD加载器。模块化加载工具可以在你的应用中按需加载模块代码。 需要再次提醒一下，AMD 和 CommonJS 的最主要区别是AMD是异步加载模块的。这也就意味着你不是必须把所有的代码打包到一个文件里，模块加载不影响后续语句执行，逐步加载的的模块也不会导致页面阻塞无法响应。 不过在实际应用中，为了避免用户过多的请求对服务器造成压力。大多数的开发者还是选择用RequireJS optimizer, r.js一类的构建工具来合并和压缩AMD的模块。 总的来说，AMD 和 CommonJS 在构建中最大的区别是，在开发过程中，采用AMD的应用直到正式上线发布之前都不需要构建。 要是你对CommonJS vs. AMD的讨论感兴趣，可以看这一篇AMD is Not the Answer WebpackWebpack 是新推出的构建工具里最受欢迎的。它兼容CommonJS, AMD, ES6各类规范。 也许你会质疑，我们已经有这么多诸如Browserify 或 RequireJS 的工具了，为什么还需要 Webpack 呢？究其原因之一，Webpack 提供许多例如 code splitting（代码分割） 的有用功能，它可以把你的代码分割成一个个的 chunk 然后按需加载优化性能。 举个例子，要是你的Web应用中的一些代码只在很少的情况下才会被用到，把它们全都打包到一个文件里是很低效的做法。所以我们就需要 code splitting 这样的功能来实现按需加载。而不是把那些很少人才会用到的代码一股脑儿全都下载到客户端去。 code splitting 只是 Webpack 提供的众多强大功能之一。当然，网上也为这些模块化构建工具吵得不可开交。你要是感兴趣的话也可以在下面这些地方观摩一下： https://gist.github.com/substack/68f8d502be42d5cd4942Browserify vs. WebpackBrowserify VS Webpack ES6 模块看他们吵够了的话，接下来我就要介绍一下ES6模块了。假如你采用ES6模块，在不远的将来对那些构建工具的需求可能会小一些。首先我们还是看看ES6模块是怎么加载的吧。 ES6模块和CommonJS, AMD一类规范最主要的区别是，当你载入一个模块时，载入的操作实际实在编译时执行的——也就是在代码执行之前。所以去掉那些不必要的exports导出语句可以优化我们应用的性能。 有一个经常会被问到的问题：去除exports和冗余代码消除（UglifyJS一类工具执行后的效果）之间有什么区别？ 答案是这个要具体情况具体分析，感兴趣的话可以上Github看这个Repo：Rollup’s wiki 让ES6模块与冗余代码消除（Dead code elimination）不同的是一种叫做tree shaking的技术。Tree shaking其实恰好是冗余代码消除的反向操作。它只加载你需要调用的代码，而不是删掉不会被执行的代码。我们还是用一个具体的例子说明吧： 假设我们有如下一个使用ES6语法，名为 utils.js 的函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344export function each(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;export function filter(collection, test) &#123; var filtered = []; each(collection, function(item) &#123; if (test(item)) &#123; filtered.push(item); &#125; &#125;); return filtered;&#125;export function map(collection, iterator) &#123; var mapped = []; each(collection, function(value, key, collection) &#123; mapped.push(iterator(value)); &#125;); return mapped;&#125;export function reduce(collection, iterator, accumulator) &#123; var startingValueMissing = accumulator === undefined; each(collection, function(item) &#123; if(startingValueMissing) &#123; accumulator = item; startingValueMissing = false; &#125; else &#123; accumulator = iterator(accumulator, item); &#125; &#125;); return accumulator;&#125; 现在我们也不清楚到底需要这个函数的哪些功能，所以先全部引入到 main.js 中： //main.jsimport * as Utils from ‘./utils.js’;之后我们再调用一下 each 函数： //main.jsimport * as Utils from ‘./utils.js’; Utils.each([1, 2, 3], function(x) { console.log(x) });通过 “tree shaken” 之后的 main.js 看起来就像下面这样：123456789101112131415//treeshake.js function each(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;;each([1, 2, 3], function(x) &#123; console.log(x) &#125;);注意到这里只导出了我们调用过的 each 方法。 再如果我们只调用 filter 方法的话：123456789101112131415161718192021222324252627282930//main.jsimport * as Utils from &apos;./utils.js&apos;;Utils.filter([1, 2, 3], function(x) &#123; return x === 2 &#125;);&quot;Tree shaken&quot; 之后就会变成这样：function each(collection, iterator) &#123; if (Array.isArray(collection)) &#123; for (var i = 0; i &lt; collection.length; i++) &#123; iterator(collection[i], i, collection); &#125; &#125; else &#123; for (var key in collection) &#123; iterator(collection[key], key, collection); &#125; &#125; &#125;;function filter(collection, test) &#123; var filtered = []; //注意在filter中调用了each，所以两个方法都会被引入 each(collection, function(item) &#123; if (test(item)) &#123; filtered.push(item); &#125; &#125;); return filtered;&#125;;filter([1, 2, 3], function(x) &#123; return x === 2 &#125;); 很神奇不是么？ 你也可以自己在Rollup.js的实时预览编辑器里做做试验：live demo and editor 构建ES6模块现在我们已经了解到ES6模块载入的与众不同了，但我们还没有聊到底该怎么构建ES6模块。 因为浏览器对ES6模块的原生支持还不够完善，所以现阶段还需要我们做一些补充工作。 让ES6模块在浏览器中顺利运行的常用方法有以下几种： 1.使用语法编译器（Babel或Traceur）来把ES6语法的代码编译成ES5或者CommonJS, AMD, UMD等其他形式。然后再通过Browserify 或 Webpack 一类的构建工具来进行构建。 2.使用Rollup.js，这其实和上面差不多，只是Rollup还会捎带的利用“tree shaking”技术来优化你的代码。在构建ES6模块时Rollup优于Browserify或Webpack的也正是这一点，它打包出来的文件体积会更小。Rollup也可以把你的代码转换成包括ES6, CommonJS, AMD, UMD, IIFE在内的各种格式。其中IIFE和UMD可以直接在浏览器里运行，AMD, CommonJS, ES6等还需要你通过Browserify, Webpack, RequireJS一类的工具才能在浏览器中使用。 小心踩坑这里有一些坑还需要和大家说明一下。转换语法优雅的ES6代码以便在浏览器里运行并不是一件令人舒爽的事情。 问题在于，什么时候我们才能免去这些多余的工作。 令人感动的答案是：“差不多快了。” ECMAScript目前包含一个名为ECMAScript 6 module loader API 的解决方案。简单来讲，这个解决方案允许你动态加载模块并缓存。还是来举例说明：12345678910111213141516171819202122### myModule.jsexport class myModule &#123; constructor() &#123; console.log(&apos;Hello, I am a module&apos;); &#125; hello() &#123; console.log(&apos;hello!&apos;); &#125; goodbye() &#123; console.log(&apos;goodbye!&apos;); &#125;&#125;### main.jsSystem.import(&apos;myModule&apos;).then(function(myModule) &#123; new myModule.hello();&#125;);// ‘Hello!, I am a module!’ 同样，你可以在script标签上设置type=module的属性来直接定义模块：12345&amp;lt;script type=&quot;module&quot;&amp;gt; // loads the &apos;myModule&apos; export from &apos;mymodule.js&apos; import &#123; hello &#125; from &apos;mymodule&apos;; new Hello(); // &apos;Hello, I am a module!&apos;&amp;lt;/script&amp;gt; 更加详细的介绍也可以在Github上查看：es6-module-loader 如果你现在就想测试这个解决方案的话，我在这里也安利一下 SystemJS. SystemJS支持在浏览器端和Node动态加载之前介绍过所有格式的模块（ES6 modules, AMD, CommonJS等），通过把已加载的模块还存在”module registry”里来避免重复加载。它也同样支持转换ES6的代码至其他格式。 我们已经有了原生ES6模块，还需要那些乱七八糟的玩意儿么？越来越多的人使用ES6模块产生了一些有趣的影响： HTTP/2 出现之后，模块化构建工具是不是都该被淘汰了？ 在HTTP/1中，一次TCP连接只允许一个请求，所以我们需要通过减少载入的文件数来优化性能。而HTTP/2改变了这一切，请求和响应可以并行，一次连接也允许多个请求。 每次请求的消耗也会远远小于HTTP/1，所以载入一堆模块就不再是一个影响性能的问题了。所以许多人认为打包模块完全就是多余的了。这听起来很合理，但我们也需要具体情况具体分析。 其中有一条，模块化构建解决了一些HTTP/2解决不了的问题。例如去除冗余的代码以压缩体积。要是你开发的是一个对性能要求很高的网站，模块化构建从长远上考虑会给你带来更多好处。当然，要是你不那么在意性能问题，以后完全就可以省却这些烦人的步骤了。 总之，我们离所有的网站都采用HTTP/2传输还有相当一段时间。短期内模块化构建还是很有必要的。 要是你对HTTP/2的其他特性也感兴趣，可以查阅这里：HTTP/2 CommonJS , AMD, UMD这类标准会过时么？ 一旦ES6成为了模块化的标准，我们还需要这些非原生的东西么？ 这点还值得商榷。 在JavaScript中采用统一标准，通过import和export来使用模块，省略所有繁杂的多余步骤确实很爽。不过到底要多久ES6才能成为真正的模块化标准呢？ 反正不会很快。 并且开发者也有各自的偏好，“唯一的解决方案”永远也不会存在。 总结我希望这两篇文章对于你理解JS模块有所帮助，要是你忘了之前聊过的内容，可以现在点开再看看：","tags":[]},{"title":"Webpack傻瓜式指南","date":"2015-07-17T16:00:00.000Z","path":"2015/07/18/webpack/","text":"Webpack最近很热，我一开始是想翻译一篇国外关于webpack的佳作，但是找来找去也没有一篇让我感觉到很满意的，好多都是一步到位，满屏幕都是React＋Webpack，官方文档写的不太好，好多点都没有解释的详细，所以我参考了几篇文章，写一篇傻瓜式指南。本文适合第一次接触webpack的朋友，如果是老鸟，就不用看了。这是系列的第一篇，主要讲他最基本的用法。 比较如果你熟悉原来一系列的构建工具，grunt或者gulp之类的，这里有一篇webpack和他们比较的文章可以读一读。 Webpack Compared 安装先装好node和npm，因为webpack是一个基于node的项目。然后 npm install -g webpack 总览官网对webpack的定义是MODULE BUNDLER，他的目的就是把有依赖关系的各种文件打包成一系列的静态资源。 请看下图 webpack简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。 这个配置文件主要分为三大块 entry 入口文件 让webpack用哪个文件作为项目的入口output 出口 让webpack把处理完成的文件放在哪里module 模块 要用什么不同的模块来处理各种类型的文件下面我们就一步一步来新建一个简单的项目 建立项目建一个文件夹，然后新建一个package.json的文件在项目根目录下 mkdir webpackcd webpacknpm init 一直点回车 如果懒得填一些信息如果你使用git管理你的这个项目的话，建议你新建一个.gitignore文件，不要让git提交一些node依赖的模块， 你也可以参考github的例子 gitignore/Node.gitignore at master · github/gitignore · GitHub 我们这里就简单一点 node_modules 项目结构现在项目里面就有一个package.json， 我们多加一点东西，慢慢丰富它的内容。 /appindex.jssub.jspackage.jsonwebpack.config.js添加了两个js文件，添加了最重要的webpack的配置文件，我们还是从非常简单的hello world开始玩起，webpack原生直接支持AMD和CommonJS两种格式，如果你想使用ES6的风格，这点以后再提。 JS代码1234567891011121314151617sub.js//我们这里使用CommonJS的风格function generateText() &#123; var element = document.createElement(&apos;h2&apos;); element.innerHTML = &quot;Hello h2 world&quot;; return element;&#125;module.exports = generateText;index.jsvar sub = require(&apos;./sub&apos;);var app = document.createElement(&apos;div&apos;);app.innerHTML = &apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;;app.appendChild(sub());document.body.appendChild(app); 代码写完了，完成一个很简单的功能，新建一个单独的module，并且在另外一个module里面引用他，最后会在页面里面输出两个标题。 配置Webpack现在开始配置webpack，目标是把这两个js文件合并成一个文件. 我们可以自己在build文件夹里面手动建一个index.html文件夹，然后再把合并以后的js引用在里面，但是这样有些麻烦，所以我们这里安装一个plugin，可以自动快速的帮我们生成HTML。 npm install html-webpack-plugin –save-dev好 有了这个插件 开始写config文件12345678910111213141516171819202122var path = require(&apos;path&apos;);var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;);//定义了一些文件夹的路径var ROOT_PATH = path.resolve(__dirname);var APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);var BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);module.exports = &#123; //项目的文件夹 可以直接用文件夹名称 默认会找index.js 也可以确定是哪个文件名字 entry: APP_PATH, //输出的文件名 合并以后的js会命名为bundle.js output: &#123; path: BUILD_PATH, filename: &apos;bundle.js&apos; &#125;, //添加我们的插件 会自动生成一个html文件 plugins: [ new HtmlwebpackPlugin(&#123; title: &apos;Hello World app&apos; &#125;) ]&#125;; 然后在项目根目录运行 webpack终端显示一堆信息，然后告诉你成功了。 你可以使用webpack –help看看一些运行的时候可选的参数 你会发现多出来一个build文件夹，直接点开里面的html文件，你会发现我们可爱的“hello world”已经插入到页面了。我们的任务完成了，成功生成html，合并js，html引入了js，js被执行了。 配置webpack-dev-server上面任务虽然完成了，但是我们要不断运行程序然后查看页面，所以最好新建一个开发服务器，可以serve我们pack以后的代码，并且当代码更新的时候自动刷新浏览器。 安装webpack-dev-server npm install webpack-dev-server –save-dev安装完毕后 在config中添加配置1234567891011121314151617module.exports = &#123; .... devServer: &#123; historyApiFallback: true, hot: true, inline: true, progress: true, &#125;, ...&#125;然后再package.json里面配置一下运行的命令,npm支持自定义一些命令...&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;&#125;,... 好了，万事具备了，在项目根目录下输入npm start,一堆花花绿绿的信息后server已经起来了，在浏览器里面输入http://localhost:8080 发现伟大的hello world出现了，在js里面随便修改一些输出然后保存, boom!浏览器自动刷新，新的结果出现了。 拓展阅读 如果你的服务器端使用的是express框架，你还可以直接安装express的middleware，webpack配合express，很好用。 npm install webpack-dev-middleware –save-dev更多的详情 请参考这篇文章 Using React with Webpack Tutorial 添加CSS样式现在来添加一些样式，webpack使用loader的方式来处理各种各样的资源，比如说样式文件，我们需要两种loader，css-loader 和 style－loader，css-loader会遍历css文件，找到所有的url(…)并且处理。style-loader会把所有的样式插入到你页面的一个style tag中。 安装我们的loader12345678910111213141516171819202122232425npm install css-loader style-loader --save-dev配置loader，在webpack.config.js中 devServer: &#123; historyApiFallback: true, hot: true, inline: true, progress: true, &#125;, ... module: &#123; loaders: [ &#123; test: /\\.css$/, loaders: [&apos;style&apos;, &apos;css&apos;], include: APP_PATH &#125; ] &#125;, ... plugins: [ new HtmlwebpackPlugin(&#123; title: &apos;Hello World app&apos; &#125;) ] 看loaders的书写方式，test里面包含一个正则，包含需要匹配的文件，loaders是一个数组，包含要处理这些程序的loaders，这里我们用了css和style，注意loaders的处理顺序是从右到左的，这里就是先运行css-loader然后是style-loader. 新建一个样式文件 main.css h1 { color: red;}记得在入口文件index.js中引用 require(‘./main.css’);然后发现标题变成红色的了，webpack的理念是基于项目处理的，把对应的文件格式给对应的loader处理，然后你就不用管了，它会决定怎么压缩，编译。 那现在想使用一些有爱的css预编译程序，来点sass吧。 你可能已经想到了，再来个loader就行啦，确实是这样简单。 npm install sass-loader –save-dev稍微修改一下config，删掉我们先前添加的css规则，加上下面的loader { test: /\\.scss$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;], include: APP_PATH }, 添加两个sass文件，variables.scss和main.scss variables.scss $red: red;main.scss @import “./variables.scss”; h1 { color: $red;}在index.js中引用 require(‘./main.scss’);然后发现标题如愿变红，相当简单吧。 处理图片和其他静态文件 这个和其他一样，也许你也已经会玩了。安装loader，处理文件。诸如图片，字体等等，不过有个神奇的地方它可以根据你的需求将一些图片自动转成base64编码的，为你减轻很多的网络请求。 安装url-loader npm install url-loader –save-dev配置config文件 { test: /\\.(png|jpg)$/, loader: &apos;url?limit=40000&apos; } 注意后面那个limit的参数，当你图片大小小于这个限制的时候，会自动启用base64编码图片。 下面举个栗子。 新建一个imgs文件夹，往里面添加一张崔叔的照片。在scss文件中添加如下的东西。 @import “./variables.scss”; h1 { color: $red; background: url(‘./imgs/avatar.jpg’);}npm start, 然后查看图片的url，发现神奇。 添加第三方库有的时候还想来点jquery，moment，undersocre之类的库，webpack可以非常容易的做到这一点，有谣言说Bower即将停止开发了, 作者推荐都使用npm来管理依赖。那么我们现在安装在我们的app中添加jquery和moment的支持。 npm install jquery moment –save-dev在js中引用 var sub = require(‘./sub’);var $ = require(‘jquery’);var moment = require(‘moment’);var app = document.createElement(‘div’);app.innerHTML = ‘Hello World it‘;document.body.appendChild(app);app.appendChild(sub());$(‘body’).append(‘look at me! now is ‘ + moment().format() + ‘‘);看看浏览器，成功！ jquery和moment现在都起作用了！ 添加ES6的支持如果现在你的项目还没有对ES6的语法支持，那就有点没有逼格了，其实大家都知道这个也很简单，因为我们有伟大的Babel 首先 装各种loader npm install babel-loader babel-preset-es2015 –save-dev配置我们的config文件 … { test: /.jsx?$/, loader: ‘babel’, include: APP_PATH, query: { presets: [‘es2015’] } },…es2015这个参数是babel的plugin，可以支持各种最新的es6的特性，具体的情况看这个链接。 Babel es2015 plugin 现在我们可以改掉CommonJS风格的文件了。1234567891011121314151617181920212223sub.jsexport default function() &#123; var element = document.createElement(&apos;h2&apos;); element.innerHTML = &quot;Hello h2 world hahaha&quot;; return element;&#125;index.jsimport &apos;./main.scss&apos;;import generateText from &apos;./sub&apos;;import $ from &apos;jquery&apos;;import moment from &apos;moment&apos;;let app = document.createElement(&apos;div&apos;);const myPromise = Promise.resolve(42);myPromise.then((number) =&gt; &#123; $(&apos;body&apos;).append(&apos;&lt;p&gt;promise result is &apos; + number + &apos; now is &apos; + moment().format() + &apos;&lt;/p&gt;&apos;);&#125;);app.innerHTML = &apos;&lt;h1&gt;Hello World it&lt;/h1&gt;&apos;;document.body.appendChild(app);app.appendChild(generateText());我们上面测试了import, export，const，let，promise等一系列es6的特性。 最后完美的输出界面。","tags":[]},{"title":"JavaScript 作用域和作用域链","date":"2015-07-12T16:00:00.000Z","path":"2015/07/13/propority/","text":"作用域就是变量或者函数可访问的范围，它分为全局作用域和本地作用域。全局作用域：所有属于浏览器 window 对象的变量或者函数都归属于全局作用域。本地作用域：以函数为边界的区块，也可以理解成除了全局作用域，其它的都可以看作是局部作用域，而全局作用域和本地作用域就组成了一条作用域链。我们可以看看下面这个例子来具体说明什么是全局作用域，什么是局部作用域：12345678910111213141516171819202122232425262728293031&amp;lt;script&amp;gt;// 定义全局变量var globleAttr = &quot;我是全局变量&quot;;// 定义全局函数 globleFnAfunction globleFnA()&#123; console.log(&quot;我是一个全局函数&quot;);&#125;// 定义全局函数 globleFnBfunction globleFnB()&#123; // 定义局部变量 var localAttr = &quot;我是局部变量&quot;; // 定义局部函数 function localFn()&#123; console.log(&quot;我是局部函数&quot;); &#125; // 调用全局函数 globleFnA globleFnA(); // 在函数内打印变量 console.log(globleAttr); // 结果：我是全局变量 console.log(localAttr); // 结果：我是局部变量&#125;// 在全局下打印变量console.log(localAttr); // 结果：localAttr is not defined（变量未定义）console.log(globleAttr); // 结果：我是全局变量// 在全局作用域中调用全局函数 globleFnAglobleFnA(); // 结果：我是一个全局函数// 在全局作用域中调用全局函数 globleFnBglobleFnB();// 在全局作用域中调用局部函数 localFnlocalFn(); // 结果：localFn is not defined（函数未定义）&amp;lt;/script&amp;gt; 运行代码后就会输出如代码行中注释中的结果。从上面的代码可以得出一个结论，局部作用域下的函数可以访问全局作用域中的变量和函数 ，而全局作用域里头的函数却无法访问本地作用域里的变量和函数，这就是作用域链在作怪。 作用域链在 JavaScript 中是一个非常重要的概念。因为不管你用 JavaScript 实现何种功能，只要你是在用 JavaScript 写代码，你都时时刻刻跟作用域链打交道。说了那么多，作用域链究竟是个什么东西，又有什么用呢？下面我们还得花点笔墨来说说。 我们都知道在 JavaScript 中一切皆对象，包括函数。函数里面放着可供代码访问的数据资源和只有 JavaScript 引擎才能访问的内部数据资源，其中一个就是 scope 属性，为什么要在这里提到 scope 属性，因为在函数执行的时候会把作用域链保存在 scope 上。当我们创建一个函数后，会创建一个包含全局变量对象的作用域链并保存在此函数内部的 scope 属性中。而当函数被执行时，会从 scope 中复制一份作为执行环境的作用域链，并且把活动对象（即此函数的变量对象）放到作用域链的最前端。 我们也可以这样理解：正在执行的函数有一个属于自己的执行环境，这个执行环境对应着一个作用域链和一个活动对象。 作用域链上挂着与当前执行函数有关的变量对象（有关的意思是指当前执行函数可能会用到的数据资源）。作用域链的最前端是活动对象，什么是活动对象可以往回看，其它变量对象按顺序从里往外依次排列，也就是说它是一个对象指针列表。当需要查询变量或者函数时（在这里我们假设要查询一个变量x），那么程序会先从活动对象查找，如果找到那就停止查找，如果在活动对象中没找到变量x，再往父级的变量对象查找，如果还没有找到，继续一层一层往上查询，直到查询到变量x为止，如果还是没找到，就会报“未定义”的错。我们可以简单的把作用域链理解成一本字典，用于查询相关的数据资源。 从上面的字里行间我们可以得知作用域链的搜索是单向的，从最前端开始往外层作用域查询，这样一级一级往外冒，直到作用域链的最末端（全局作用域 的变量对象），这就是为什么外层函数无法访问内层函数数据资源的原因所在。 我们就拿上面那段代码中的 globleFnB 函数作为作用域链的 demo。在讲解例子之前，我们需要再来看一个例子，就是当我们打开浏览器后会发生什么。 当我们打开浏览器后，就会生成一个全局的执行环境，一条执行环境对应的作用域链和一个活动对象，这个执行环境属于 window 对象。这个执行环境只会在浏览器关闭后才会被销毁，这就是我们常常说的尽量不要把变量定义为全局变量的原因，如果有一个非常大的 JavaScript 程序，并且里面的所有变量函数都挂在 window 对象下，那么可能就会产生一定的性能问题，因为这些数据资源不会在函数执行完后销毁，而是一直占用着内存资源，只有当网页或者浏览器关闭后才会被销毁并释放内存空间。 回到正题，当我们启动浏览器后就会创建一个这样全局环境，如图：JavaScript 作用域和作用域链 当我们的 globleFnB 函数执行时，会创建一个执行环境，一个活动对象，一个作用域链，而上面那个window 对象就变成了作用域链中的1号位置，当前执行环境总是排在第一位。如图： JavaScript 作用域和作用域链需要注意的是，不管当前是哪一个函数正在执行，他的执行环境都会有一条属于自己的作用域链，当函数执行完后，活动对象里的数据资源都会被销毁。但也不总是这样，也有例外的情况，那就是在有闭包的代码中，是可以访问到局部变量的。","tags":[]},{"title":"前端工程师如何快速的开发一个微信JSSDK应用？","date":"2015-07-12T16:00:00.000Z","path":"2015/07/13/weixin7/","text":"亲们，订阅号出来已经很久了，你是不是错过了什么？可能很多攻城狮同学还没有反应过来订阅号怎么回事，就马上要被微信的应用号秀一脸了。在应用号还没有正式出来之前，我们赶紧一起来看看如何给自己的订阅号加个网页功能吧。 一、订阅号网页与普通的HTML5网页的区别可能会有很多同学还没有弄清楚普通的HTML网页与订阅号网页的差别，我在这里简单的说明一下。 订阅号的网页就是微信的网页，普通的网页是W3C规范下的网页。 订阅号的网页通常是以遵守W3C的网页规范为前提的，但是也有可能有所差异，具体要根据微信浏览器的解析能力而定，但是通常是支持大部分的W3C标准的。一定程度上W3C规范的网页作为订阅号的网页是没有问题的。 订阅号网页需要微信的认证。在认证后通常可以获得比普通的W3C网页更多的能力。比如扫描二维码，微信支付，拍照片，录音，WIFI设备等能力。所以订阅号网页具备比普通的W3C网页更强的终端能力，可以更好的提供移动端的服务，对于很多个人与公司来说都是值得尝试的。 二、开发订阅号网页需要那些技术？在了解了订阅号网页与普通网页的差别后，我们基本上知道了开发订阅号所需要的基本的技术。 HTML + CSS + JS的前端技术 服务器技术 微信开发是所用到的SDK技术 由于1,2都是通用技术，所以我不在这里详细介绍了。我们现在主要介绍一下微信开发所需要的SDK技术。 三、订阅号开发的微信技术订阅号开发所需要的纯微信上的技术准备如下： 公共号配置信息包括app id, app secret 服务器验证请求接口即需要有一个接口可以与微信服务器对接，用于处理微信服务器返回的消息 一个引入了JSSDK的微信页面 公共号配置信息 公共号配置信息需要登录 http://mp.weixin.qq.com 获取，关于如何注册微信个人订阅号的问题请查看微信相关帮助。不在这里赘述了。配置信息所在的位置是：开发=》基本配置在开发者ID栏目里有两个东西 AppID(应用ID) AppSecret(应用密钥)AppID是固定不变的，AppSecret是可以变化的。secret最好定期变化，以防止泄漏造成安全问题。 一个备案的服务器域名 域名备案是中国特色，所以大家需要好好享受这个特色。我就不在这里详细介绍了。有了域名后，将域名填入：设置 =》 公众号设置 =》 功能设置 =》 JS接口安全域名然后填入你想放的域名即可。 准备一个JSSDK的微信页面 准备微信页面是我们这次的重点。在这里会涉及到所有关于微信页面的制作的业务逻辑。我们将会分解每个步骤，详细讲解原理与操作。由于正式上线公共帐号需要备案的域名，所以对于大部分人来说还是有点不方便。所以在这里我主要讲解如何开发与测试订阅号微信页面，然后将这个过程复制到已经备案的域名所对应的服务器上即可。 第一步是制作JSSDK的HTML页面 首先是一个最简单的包含有JSSDK的HTML代码： &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=”UTF-8”&gt; &lt;meta name=viewport content=”width=device-width”&gt; &lt;title&gt;微信网页&lt;/title&gt; &lt;script src=”http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&amp;gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;微信JSSDK网页&lt;/h1&gt;&lt;/body&gt; &lt;/html&gt; 然后添加JS初始代码为了代码的简洁，我们引入了jquery. &lt;script src=”https://code.jquery.com/jquery-2.1.4.min.js&quot;&gt;&lt;/script&amp;gt;然后添加初始化jssdk的代码 &lt;script&gt; $(document).ready(function() { // 根据实际填写接口的配置地址 // 这里的接口地址是基于node-weixin配置的。 var url = “/jssdk/config”; // 当前的网页请求地址 var weixinUrl = location.href.split(&apos;#&apos;)[0]; $.ajax({ url: url, //这个地址是服务器配置JSSDK的地址 data: { // 这个地址是发生jssdk调用的url地址 // 用于服务器配置 url: weixinUrl } }).success(function(json) { // 获得服务器返回的配置信息 var data = json.data; var config = {}; for (var k in json.data) { config[k] = json.data[k]; } // config.debug = true; // 添加你需要的JSSDK的权限 config.jsApiList = [ &apos;checkJsApi&apos;, &apos;scanQRCode&apos; ]; config.timestamp = parseInt(config.timestamp); wx.config(config); wx.ready(function() { alert(&quot;微信jssdk配置成功!&quot;); }); wx.error(function(res) { alert(&apos;微信JSSDK配置失败！&apos;); }); }); }); &lt;/script&gt;效果如下 ：对于配置JSSDK来说，最重要的是需要在服务器端提供一个配置参数，这个可以参考node-weixin的参数配置接口。这样前端只需要将当前的URL转入就可以完成整个JSSDK的参数的匹配。获得配置信息后只要将接口权限配置一下就可以完成整个JSSDK的配置了。 调用JSSDK的接口APIJSSDK的接口API有很多，我们可以通过一个简单的扫描调用来验证我们的代码的正确性。 首先我们要添加一个可以点击的HTML元素： &amp;lt;h2 class=&quot;qrcode&quot;&amp;gt;点击扫描&amp;lt;/h2&amp;gt; 然后我们将wx.ready里的回调函数进行重写： function() { $(‘.qrcode’).click(function () { wx.scanQRCode({ // 默认为0，扫描结果由微信处理，1则直接返回扫描结果， needResult: 1, // 可以指定扫二维码还是一维码，默认二者都有 scanType: [“qrCode”, “barCode”], success: function (res) { // 当needResult 为 1 时，扫码返回的结果 var result = res.resultStr; alert(result); } }); });}这样我们在这个class为qrcode的HTML元素上点击后就可以调用二维码扫描功能了。 利用WeTop进行微信网页 上面的过程我们没有讨论到服务器，是因为我们使用了wetop，wetop已经帮你将所有的服务器测试环境配置好了。所以你完全不用自己开发服务器就可以进行微信的前端开发了。使用WeTop的方法非常简单。 在配置 =》 公共号参数配置 =》 app 将所有的参数配置完成 在接口 =&gt; AccessToken获取测试 测试能否正确的获取token 在接口 =&gt; jssdk 页面测试 里测试 通过指定模板地址，就可以将自己的网页放到手机服务器上进行测试了。JSSDK测试的默认地址是jssdk.html。 WeTop支持(Windows, Linux, Mac OS三种桌面OS），可以到http://yun.baidu.com/s/1nuBpOBR进行下载或者google搜索node-weixin-desktop找到源码，自行进行编译。","tags":[]},{"title":"Welcome To My Blog","date":"2015-06-12T16:00:00.000Z","path":"2015/06/13/me/","text":"欢迎您的到来！","tags":[]},{"title":"Javascript闭包","date":"2015-05-12T16:00:00.000Z","path":"2015/05/13/lessandsass/","text":"Javascript闭包——懂不懂由你，反正我是懂了作者: FrankFang 来源: 博客园 原文链接 不才译文见下，见笑了。 Peter Mortensen问：就像老Albert所说的，“如果你不能向一个六岁的孩子解释清楚，那么其实你自己根本就没弄懂。”好吧，我试着向一个27岁的朋友就是JS闭包（JavaScript closure）却彻底失败了。你们会怎么把它解释给一个充满好奇心的六岁孩子听呢？注：我看过StackOverflow上给出的示例，但根本没用。 Ali的回答： 当function里嵌套function时，内部的function可以访问外部function里的变量。 function foo(x) { var tmp = 3; function bar(y) { alert(x + y + (++tmp)); } bar(10);}foo(2) 不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。 但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。 function foo(x) { var tmp = 3; return function (y) { alert(x + y + (++tmp)); }}var bar = foo(2); // bar 现在是一个闭包bar(10); 上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。 但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1. （考虑到六岁这个限制：我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。） 注：现在来整点儿七岁的内容。 上面的x是一个字面值（值传递），和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。 那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！ function foo(x) {var tmp = 3;return function (y) { alert(x + y + tmp); x.memb = x.memb ? x.memb + 1 : 1; alert(x.memb); }}var age = new Number(2);var bar = foo(age); // bar 现在是一个引用了age的闭包bar(10); 不出我们意料，每次运行bar(10)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量——age，运行两次bar(10)后，age.memb会变成2. 这和HTML对象的内存泄漏有关，呃，不过貌似超出了答题的范围。 JohnMerlino 对Ali说： 这里有一个不用return关键字的闭包例子： function closureExample(objID, text, timedelay) { setTimeout(function() { document.getElementById(objID).innerHTML = text; }, timedelay);}closureExample(‘myDiv’, ‘Closure is created’, 500); 深夜1:37 John Pick这样回答： JS里的function能访问它们的： 1. 参数 2. 局部变量或函数 3. 外部变量（环境变量？），包括123.1 全局变量，包括DOM。3.2 外部函数的变量或函数。 如果一个函数访问了它的外部变量，那么它就是一个闭包。 注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。 一个典型的例子就是全局变量的使用。 mykhal这样回答： Wikipedia对闭包的定义是这样的：In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function. 从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。 Since scope-defining construction in Javascript is a function, not a code block like in many other languages, what we usually mean by closure in Javascript is a fuction working with nonlocal variables defined in already executed surrounding function. 闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。 var db = (function() {// 创建一个隐藏的object, 这个object持有一些数据// 从外部是不能访问这个object的var data = {};// 创建一个函数, 这个函数提供一些访问data的数据的方法return function(key, val) { if (val === undefined) { return data[key] } // get else { return data[key] = val } // set }// 我们可以调用这个匿名方法// 返回这个内部函数，它是一个闭包})();db(‘x’); // 返回 undefineddb(‘x’, 1); // 设置data[‘x’]为1db(‘x’); // 返回 1 // 我们不可能访问data这个object本身// 但是我们可以设置它的成员 看了这么多外国大牛的解答，不知道你懂还是不懂，反正我是懂了。","tags":[]},{"title":"JS实现继承的几种方式","date":"2015-04-08T16:00:00.000Z","path":"2015/04/09/jsjichen5/","text":"JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。 JS继承的实现方式既然要实现继承，那么首先我们得有一个父类，代码如下： // 定义一个动物类 function Animal (name) { // 属性 this.name = name || ‘Animal’; // 实例方法 this.sleep = function(){ console.log(this.name + ‘正在睡觉！’); }}// 原型方法Animal.prototype.eat = function(food) { console.log(this.name + ‘正在吃：’ + food);}; 1、原型链继承 核心： 将父类的实例作为子类的原型 function Cat(){}Cat.prototype = new Animal();Cat.prototype.name = ‘cat’; // Test Code var cat = new Cat();console.log(cat.name);console.log(cat.eat(‘fish’));console.log(cat.sleep());console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到简单，易于实现缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中无法实现多继承来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）创建子类实例时，无法向父类构造函数传参推荐指数：★★（3、4两大致命缺陷） 2、构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） function Cat(name){ Animal.call(this); this.name = name || ‘Tom’;} // Test Code var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true特点： 解决了1中，子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数可以实现多继承（call多个父类对象）缺点： 实例并不是父类的实例，只是子类的实例只能继承父类的实例属性和方法，不能继承原型属性/方法无法实现函数复用，每个子类都有父类实例函数的副本，影响性能推荐指数：★★（缺点3） 3、实例继承核心：为父类实例添加新特性，作为子类实例返回 function Cat(name){ var instance = new Animal(); instance.name = name || ‘Tom’; return instance;} // Test Code var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果缺点： 实例是父类的实例，不是子类的实例不支持多继承推荐指数：★★ 4、拷贝继承 function Cat(name){ var animal = new Animal(); for(var p in animal){ Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || ‘Tom’;} // Test Code var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true特点： 支持多继承缺点： 效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）推荐指数：★（缺点1） 5、组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 function Cat(name){ Animal.call(this); this.name = name || ‘Tom’;}Cat.prototype = new Animal(); // Test Code var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例不存在引用属性共享问题可传参函数可复用缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）推荐指数：★★★★（仅仅多消耗了一点内存） 6、寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 function Cat(name){ Animal.call(this); this.name = name || ‘Tom’;}(function(){ // 创建一个没有实例方法的类 var Super = function(){}; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();})(); // Test Code var cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true特点： 堪称完美缺点： 实现较为复杂推荐指数：★★★★（实现复杂，扣掉一颗星） 附录代码：示例一： function Animal (name) { // 属性 this.name = name || ‘Animal’; // 实例方法 this.sleep = function(){ console.log(this.name + ‘正在睡觉！’); } //实例引用属性 this.features = [];}function Cat(name){}Cat.prototype = new Animal(); var tom = new Cat(‘Tom’);var kissy = new Cat(‘Kissy’); console.log(tom.name); // “Animal”console.log(kissy.name); // “Animal”console.log(tom.features); // []console.log(kissy.features); // []tom.name = ‘Tom-New Name’;tom.features.push(‘eat’); //针对父类实例值类型成员的更改，不影响 console.log(tom.name); // “Tom-New Name”console.log(kissy.name); // “Animal”//针对父类实例引用类型成员的更改，会通过影响其他子类实例console.log(tom.features); // [‘eat’]console.log(kissy.features); // [‘eat’] 原因分析： 关键点：属性查找过程 执行tom.features.push，首先找tom对象的实例属性（找不到），那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的features属性中插入值。在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。","tags":[]},{"title":"浅谈css的预编译---less语言","date":"2015-03-10T16:00:00.000Z","path":"2015/03/11/less6/","text":"正如各位所知道的一样，css是一门标记性语言，语法相对简单，对使用者的要求也比较低 。不过可乐不知道友友们有没有发现，在使用css的时候需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于一些缺乏css编写经验的猿猿来讲，写出组织良好且易于维护的 CSS 代码是相当困难的一件事情。这个时候呢，可乐悄悄地告诉你们，咱们的程序员蜀黍是无所不能的，针对这个调皮的css，专门开发了less语言。 一、less简介：1、less语言是在css的语法基础上，引入了变量，Mixin（混入），运算，以及函数等功能，可以让我们用更少的代码做更多的事情哦！ 二、.less引入（两种方式）：1、客户端使用.less文件： 先要从 http://lesscss.org 下载 less.js 文件，然后在我们需要引入 LESS 源文件的 HTML 中加入如下代码： &lt;link rel=”stylesheet/less” type=”text/css” href=”styles.less”&gt; 注意 ，此处的rel属性值是“ stylesheet/less ”哦。 还有一点就是： less源文件一定要在less.js引入之前引入 ，才能保证less源文件正确编译解析: &lt;script src=”../less.min.js”&gt;&lt;/script&gt;2、在服务器端使用：主要是借助于LESS的编译器，将less源文件编译生成最终的css文件（ 推荐 ）； LESS 在服务器端的使用主要是借助于 LESS 的编译器，将 LESS 源文件编译生成最终的 CSS 文件，目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译。 在项目开发初期，我们无论采用客户端还是服务器端的用法，我们都需要想办法将我们要用到的 CSS 或 LESS 文件引入到我们的 HTML 页面或是桥接文件中，LESS 提供了一个我们很熟悉的功能— Importing。我们可以通过这个关键字引入我们需要的 .less 或 .css 文件。 如： @import “variables.less”;.less 文件也可以省略后缀名，像这样： @import “variables”;引入 CSS 同 LESS 文件一样 ，只是 .css 后缀名不能省略。 三、.less语法简介：1、变量：一次定义，重复使用： @color:#505253;.bg-color{ background-color:@color;}.border-color{ border:1px solid @color;}如上所示： @color 就是可乐刚刚定义的变量，在 .bg-color 和 .border-color 当中都可以使用它 2、混入–Mixins：申明一个类，然后在其它类中调用当前这个类 .roundeCorers(@radius:5px){ -moz-border-radius:@radius; -webkit-border-radius:@radius; border-radius:@radius;} #header{ .roundeCorers;} #footer{ .roundeCorers(10px);}可乐注释一下：其中 @radius 是参数，不穿参数时，默认值为 5px ，如 #header 中的用法。 3.继承有一个类用了一组样式，又写了一个类也想用这个样式，可继承上个类的样式，如： 基础css样式： .base-style { font-size: 12px; color: red;}第一种继承写法： .content{ .base-style(); background-color: white;}第二种继承写法： .content{ &amp;:extend(.base-style); background-color: white;}两写法不同，编译后生成的CSS样式也不一样 第一种： .base-style{ font-size: 12px; color: red;}.content { font-size: 12px; color: red; background-color: white;}第二种： .base-style,.content{ font-size: 12px; color: red;}.content { background-color: white;} 4、嵌套规则： html： &lt;div id=”header”&gt; &lt;h1&gt;&lt;a href=””&gt;www.xdpie.com&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;自游自驾&lt;/p&gt;&lt;/div&gt;LESS： #header { display: inline; float: left; h1 { font-size: 26px; font-weight: bold; a { text-decoration: none; color: #f36; &amp;:hover { text-decoration: underline; color: #63f; } } } p { font-size: 12px; }} 5、功能和操作： 可乐给大家一个网址，供大家参考： http://less.bootcss.com/functions/ 6、逻辑控制：LESS是用mixin通过guard的方式支持简单图瓦人分支控制，比如我们要实现一个控制 ::placeholder 样式的 mixin，当传入颜色时只设置颜色，当传入声明块时输出对应的样式规则，其他情况输出一个默认的 color .mixin(@val) when (iscolor(@val)) { color: @val;}.mixin(@val) when (isruleset(@val)) { @val();}.mixin(@val) when (default()) { color: #666;}","tags":[]},{"title":"JavaScript 变量","date":"2015-02-20T16:00:00.000Z","path":"2015/02/21/js8/","text":"什么是变量变量就是用来存放数据的容器。 变量命名法变量命名是区分大小写的，并且不允许使用 JavaScript 的关键字和保留字做变量名。所有变量的命名法都是基于上面两条命名原则的。 匈牙利命名法通过在变量名前面添加相应小写字母作为前缀标示变量的作用域或类型等。前缀后面是一个或多个单词的组合，单词描述了变量的用途，比如g表示全局变量，l表示局部变量。 &lt;script&gt;var gGoodWebsite = “云库网”;function varFn(){ var lWebsiteAddress = “yunkus.com”; console.log(lWebsiteAddress);}&lt;/script&gt; 骆驼式/驼峰命名法混合使用大小写字母来组合而成的变量名。 &lt;script&gt;//格式一：var goodWebsite = “云库网”;var websiteAddress = “yunkus.com”;//格式二：var good_website = “云库网”;var website_address = “yunkus.com”;&lt;/script&gt; 帕斯卡使命名法这个跟驼峰命名法类似，只不过驼峰的第一个单词首字母小写，而帕斯卡命名法第一个单词首字母也大写。 lt;script&gt;var GoodWebsite = “云库网”;var WebsiteAddress = “yunkus.com”;&lt;/script&gt; 变量存放的数据类型基本数据类型有5种：string（字符串）、number（数字）、boolean（布尔）、Null、Undefined。引用类型数据1种：object（对象） string 类型：存储字符（比如 “Bill Gates”）的变量。number 类型：数字可以带小数点，也可以不带。boolean 类型：布尔（逻辑）只能有两个值：true 或 false。undefined 类型：声明但未初始化,且其默认初始化值为 undefined。null 类型：默认值是null，从逻辑角度讲，是表示一个空对象指针。object 类型：可通过 new Object()来创建一个对象。因为 JavaScript 拥有动态类型，所以你可以通过var 来保存前面提到的6种数据类型。在 JavaScript 中引用数据类型是保存在堆内存中的对象，这些对象不可以直接被访问的，只能通过操作存放在栈内存中的地址来查询在堆内存中的对象，即我们保存在变量中的值。 数据类型的检测typeoftypeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。它的返回值是一个字符串，该字符串说明运算数的类型。结果为string，number，boolean，undefined，function，object中的一种。 &lt;script&gt;var iString = “云库网”;var iNumber = 666;var iBoolean = true;var iNull = null;var iUndefined;var iObject = new Object();var iFn = function(){};console.log(typeof iString); // stringconsole.log(typeof iNumber); // numberconsole.log(typeof iBoolean); // booleanconsole.log(typeof iNull); // objectconsole.log(typeof iUndefined); // undefinedconsole.log(typeof iObject); // objectconsole.log(typeof iFn); // function&lt;/script&gt; 这里需要注意的是：iNull 和 iObject 都返回 object 。因为null 表示的是一个空对象指针，所以 iNull 返回的就是一个对象。有意思的事请看下面： &lt;script&gt;// 依然使用上面声明的变量，打印 iNull 和 iUndifined 的对比结果console.log(iNull == iUndifined); //true&lt;/script&gt; 竟然是 true，原来 undifined 值派生自null 值 。虽然是这样，但在平常使用中，他们还是有点不同，比如你要声明一个未定义的变量不用显式地给变量赋值undifined，只需要var str;而给变量声明null时，就必需显式地赋值，如：var obj = null;null的作用：1.告诉 JavaScript 引擎 obj 是一个用于保存对象的变量; 2.告诉 JavaScript 引擎垃圾回收机制这个变量可回收。 instanceofinstanceof 用于判断一个变量是否是某个对象的实例。它返回的是 true 或者 false 。 &lt;script&gt;var iString = new String();var iNumber = new Number();var iBoolean = new Boolean();var iObject = new Object();var iFn = new Function();console.log(iString instanceof String); // tureconsole.log(iNumber instanceof Number); // tureconsole.log(iBoolean instanceof Boolean); // tureconsole.log(iObject instanceof Object); // tureconsole.log(iFn instanceof Function); // ture&lt;/script&gt; 但是如果你像下面这样初始化这些变量，那么instanceof 就会返回 false &lt;script&gt;var iString = “云库网”;var iNumber = 666;var iBoolean = true;var iObject = new Object();var iFn = function(){}console.log(iString instanceof String); // falseconsole.log(iNumber instanceof Number); // falseconsole.log(iBoolean instanceof Boolean); // falseconsole.log(iObject instanceof Object); // tureconsole.log(iFn instanceof Function); // ture&lt;/script&gt; 这是为什么呢？原来 instanceof 运算符是用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。所以我们要通过下面这样创建变量，instanceof 才会返回 true： &lt;script&gt;var iString = new String(“云库网”);var iNumber = new Number(666);var iBoolean = new Boolean(true);var iObject = new Object();var iFn = new Function();console.log(iString instanceof String); // tureconsole.log(iNumber instanceof Number); // tureconsole.log(iBoolean instanceof Boolean); // tureconsole.log(iObject instanceof Object); // tureconsole.log(iFn instanceof Function); // ture//控制台打印 iString 的值console.log(iString); //String {0: “云”, 1: “库”, 2: “网”, length: 3, [[PrimitiveValue]]: “云库网”}// 弹出iString的值alert(iString); // 云库网&lt;/script&gt;但是这里有一个很有意思的现象，那就是控制台打印出来的 iString 结果是这样的：String {0: “云”, 1: “库”, 2: “网”, length: 3, [[PrimitiveValue]]: “云库网”}，并且你可以通过 iString[0]、 iString[1]、 iString[2] 来获取对应的值。 变量声明及初始化声明多个变量同时声明初始化多个变量的写法： &lt;script&gt;// 分开声明var a = “云库网”;var b = [“云库网”,”yunkus.com”];var c = {name:”云库网”,value:”http://yunkus.com&quot;};// 单 var 声明var a = “云库网”, b = [“云库网”,”yunkus.com”], c = {name:”云库网”,value:”http://yunkus.com&quot;};你只需要记住 var 开头，变量之间用 , 隔开，最后别忘了加 ; 。 声明但未初始化像这种例子就是考验你对 JavaScipt 的理解程度了。不过也不用着急，看完本例子后，你应该会明白。 &lt;script&gt;// 声明但未初始化变量var a;console.log(a); // undefined// 使用未声明的变量console.log(b); // Uncaught ReferenceError: b is not defined&lt;/script&gt;声明但未初始化变量跟未定义变量最大的不同就是声明但未初始化时，不会影响到后以的程序执行，而直接使用未定义的的就是，则会报错，并且后续的程序都没法继续执行。 下面还有一个挺不错的例子： &lt;script&gt;console.log(“我是第一个：” + a); // 我是第一个：undefinedvar a;console.log(“我是第二个：” + a); // 我是第二个：undefinedvar a = “云库网”;console.log(“我是第三个：” + a); // 我是第三个：云库网&lt;/script&gt; 为什么第一个打印出来的结果跟第二个打印出来的结果是一样的，在第一个之前 a 不是还没定义吗？你只需要记得一点就可以，在 JavaScript 引擎中对代码的处理可分为为两个阶段：预编译期(预处理)与执行期。预编译期JS会对本代码块中的所有声明的变量和函数进行处理，但需要注意的是此时处理函数的只是声明式函数，而且变量也只是进行了声明但未进行初始化以及赋值。只有等到函数执行了才会给变量赋值，也就是说JavaScript 引擎会先过一遍程序 ，把程序里的变量和函数都声明好，等到第二次（从上往下执行）时，才会依次（从上往下）给变量和函数赋值并执行相应函数。代码中还有一个地方需要引起你的注意的，重复声明变量 a ，那 JavaScript 引擎是怎么处理这种情况的呢？优先声明原则，也就是如果你前面已经声明了变量，那么后面如果又重复声明了，就会把后面声明的变量直接忽略掉 var 声明，但执行时还是会把 var a = “云库网” 这个字符串赋值给第一个变量 a 的。 下面还有一个更加经典的例子： &lt;script&gt;var a1 = “JavaScript”;var a2 = “jQuery”;function fn1(){ console.log(a1); a1 = “HTML5”; console.log(a1);}function fn2(){ console.log(a2); var a2 = “CSS3”; console.log(a2);}fn1();fn2();&lt;/script&gt; 它们分别都会输出什么呢？你先在脑子里过一遍，然后运行代码来对下比浏览器打印出来的结果是不是跟你想象中的一样？","tags":[]}]